<html>
    <head>
        <title data-localize="title">Yume 2kki Explorer</title>
        <link rel="shortcut icon" href="/favicon.ico">
        <style>
            @font-face {
                font-family: 'MS Gothic';
                src: url('/fonts/MS Gothic.ttf');
            }

            body {
                font-family: 'MS Gothic';
                margin: 0;
                background: url(https://img2.wikia.nocookie.net/__cb20140715140243/yume2kki/images/5/50/Wiki-background) top left repeat;
                background-blend-mode: screen;
                overflow: hidden;
            }

            .noselect {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            .content {
                background: rgba(0,0,0,0.8);
                padding-top: 0.1px;
            }

            .controls--container {
                position: absolute;
                width: 100%;
                z-index: 10;
                pointer-events: none;
            }

            .controls {
                position: absolute;
                display: flex;
                flex-wrap: wrap;
                justify-content: flex-end;
                text-align: right;
                margin: 10px;
                margin-top: 10px;
                width: calc(100% - 40px);
                min-height: 64px;
                border: 10px solid transparent;
            }

            .controls-top {
                z-index: 10;
            }

            .controls-bottom {
                pointer-events: none;
            }

            .controls-bottom.visible {
                pointer-events: all !important;
            }

            .controls--container--tab {
                position: absolute;
                width: 128px;
                z-index: 5;
                top: calc(100% - 36px);
            }

            .controls--container--tab__button {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
                height: 16px;
                padding: 6px 0 24px 0;
                font-family: 'MS Gothic';
                font-size: 18px;
                border: none;
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;
                background-image: none;
                background-color: rgba(255, 255, 255, 0.25);
            }

            .control {
                display: flex;
                align-items: center;
                padding: 8px;
            }

            .loading-container {
                width: 100%;
                height: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }

            .loading-container .loading-container__text {
                font-size: xx-large;
                margin-left: 12px;
            }

            .loading-container img {
                -ms-interpolation-mode: nearest-neighbor;
                image-rendering: pixelated;
                height: 25%;
            }

            .blocker {
                padding: 24px 24px 32px 24px !important;
            }

            .graph {
                width: 100%;
                height: 100%;
            }

            .footer {
                position: absolute;
                padding: 8px;
                padding-left: 4px;
                top: calc(100% - 36px);
                text-align: right;
                height: 26px;
                width: calc(100% - 16px);
                font-family: 'MS Gothic';
                font-size: 18px;
            }

            label {
                font-size: 18px;
                margin-left: 16px;
                font-weight: bold;
            }

            button {
                margin: 8px;
                padding: 4px;
                cursor: pointer;
                font-family: 'MS Gothic';
                font-size: 18px;
                border: 6px solid transparent;
            }

            a {
                text-decoration: none;
                padding: 4px;
                font-family: 'MS Gothic';
                font-size: 18px;
                border: 6px solid transparent;
            }

            input[type='text'], select, .slider {
                margin: 8px;
                padding: 4px;
                font-family: 'MS Gothic';
                font-size: 18px;
                border: 6px solid transparent;
            }

            .slider {
                -webkit-appearance: none;
                appearance: none;
                width: 128px;
                height: 2px;
                padding: 0 4px;
                outline: none;
            }

            .slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 24px;
                height: 38px;
                border: 6px solid transparent;
                cursor: pointer;
            }

            .slider::-moz-range-thumb {
                width: 25px;
                height: 25px;
                width: 24px;
                height: 38px;
                border: 6px solid transparent;
                cursor: pointer;
            }

            .modal {
                border: 10px solid transparent;
                padding: 0 32px 24px 24px !important;
                max-width: initial !important;
                vertical-align: top !important;
                height: 100%;
                transition: height 0.25s;
            }

            .modal__content {
                margin-right: -32px;
                overflow-y: scroll;
                height: calc(100% + 24px);
            }

            .modal__content a {
                display: inline-block;
                margin-bottom: 24px;
            }

            .modal__content::-webkit-scrollbar {
                width: 18px;
            }

            .modal__content::-webkit-scrollbar-track {
                border: 10px solid transparent;
                background-color: rgba(255, 255, 255, 0.25);
                margin-top: 24px;
            }

            .modal__content::-webkit-scrollbar-thumb {
                border: 6px solid transparent;
            }

            .modal__content::-webkit-scrollbar-button {
                height: 0px !important;
            }

            .modal__content--localized {
                padding-bottom: 16px;
            }
            
            a.close-modal {
                display: flex !important;
                align-items: center;
                justify-content: space-around;
                text-decoration: none;
                text-indent: initial !important;
                padding: 5px;
                margin: 0;
                border: none;
                top: -10px !important;
                right: -10px !important;
            }

            .autocomplete-suggestions {
                border: 6px solid transparent;
                overflow: auto;
            }

            .autocomplete-suggestion {
                padding: 2px 5px;
                white-space: nowrap;
                overflow: hidden;
            }

            .autocomplete-suggestions strong {
                font-weight: normal;
            }

            .autocomplete-group {
                padding: 2px 5px;
            }

            .autocomplete-group strong {
                display: block;
                border-bottom: 1px solid #000;
            }

            .graph-tooltip, .scene-tooltip {
                font-family: 'MS Gothic' !important;
                font-size: 16px !important;
                padding: 4px;
                border: 6px solid transparent;
            }

            .scene-nav-info {
                display: none;
            }

            .context-menu-list {
                border: 0 !important;
                padding: 0 !important;
            }

            .context-menu-item {
                border: 6px solid transparent;
            }
        </style>
        <style class="js--theme-styles">
            body {
                background-color: #000000; /*base*/
            }

            .controls, .modal {
                background: url(/images/ui/Default_Custom/containerbg.png) !important;
                border-image: url(/images/ui/Default_Custom/border.png) 12 repeat;
            }

            .controls--container--tab__button {
                color: rgba(216, 216, 216, 1); /*base*/
            }

            label, h1, h2, h3, h4, p, .close-modal, .loading-container .loading-container__text {
                background-image: url(/images/ui/Default_Custom/font1.png) !important;
                -webkit-background-clip: text;
	            -webkit-text-fill-color: transparent;
                background-clip: text;
            }

            label {
                background-size: 18px;
            }

            h1 {
                background-size: 32px;
            }

            h2 {
                background-size: 24px;
            }

            h3 {
                background-size: 18.67px;
            }

            p, h4 {
                background-size: 16px;
            }

            .modal__content::-webkit-scrollbar-track {
                border-image: url(/images/ui/Default_Custom/border.png) 12 repeat !important;
                background-color: rgba(45, 17, 23, 1); /*base*/
            }

            .modal__content::-webkit-scrollbar-thumb {
                border-image: url(/images/ui/Default_Custom/border.png) 8 round !important;
            }

            .footer {
                color: rgba(216, 216, 216, 1); /*base*/
            }

            button, a {
                color: rgba(216, 216, 216, 1); /*base*/
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-image: url(/images/ui/Default_Custom/containerbg.png);
            }

            input[type='text'], select, .slider {
                color: rgba(216, 216, 216, 1); /*base*/
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-color: rgba(45, 17, 23, 1); /*base*/
            }

            input[type='text'].selected {
                color: rgba(255, 255, 157, 1); /*alt*/
            }

            .slider::-webkit-slider-thumb {
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-color: rgba(45, 17, 23, 1); /*base*/
            }

            .slider::-moz-range-thumb {
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-color: rgba(45, 17, 23, 1); /*base*/
            }

            .autocomplete-suggestions {
                color: rgba(216, 216, 216, 1); /*base*/
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-color: rgba(45, 17, 23, 1); /*base*/
            }

            .autocomplete-selected {
                background-color: rgba(93, 65, 71, 1); /*alt*/
            }
            
            .autocomplete-suggestions strong {
                color: rgba(255, 255, 157, 1); /*alt*/
            }

            .context-menu-item, .graph-tooltip, .scene-tooltip:not(:empty) {
                color: rgba(216, 216, 216, 1) !important; /*base*/
                border-image: url(/images/ui/Default_Custom/border.png) 8 round !important;
                background-color: rgba(45, 17, 23, 1) !important; /*base*/
                background-image: url(/images/ui/Default_Custom/containerbg.png) !important;
            }

            .context-menu-item.context-menu-hover {
                color: rgba(255, 255, 157, 1) !important; /*alt*/
            }
        </style>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery-contextmenu/2.9.0/jquery.contextMenu.min.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery-modal/0.9.1/jquery.modal.min.css" />
        <script src="//unpkg.com/d3-quadtree"></script>
        <script src="//unpkg.com/d3-force"></script>
        <script src="//unpkg.com/three"></script>
        <script src="//unpkg.com/three-spritetext"></script>
        <script src="/js/yume-2kki-explorer.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.devbridge-autocomplete/1.4.10/jquery.autocomplete.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-localize/0.1.0/jquery.localize.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-contextmenu/2.9.0/jquery.contextMenu.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-contextmenu/2.9.0/jquery.ui.position.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-modal/0.9.1/jquery.modal.min.js"></script>
        <script src="https://cdn.jsdelivr.net/remarkable/1.7.1/remarkable.min.js"></script>
        <script src="/js/conn-type.js"></script>
    </head>
    <body>
        <div class="content">
            <div class="controls controls-top">
                <div class="control">
                    <label data-localize="controls.search.name" class="noselect">Search:</label>
                    <input name="searchWorld" type="text" class="js--world-input js--search-world" />
                </div>
                <div class="control">
                    <label data-localize="controls.origin.name" class="noselect">Origin:</label>
                    <input name="startWorld" type="text" class="js--world-input js--path--world-input js--start-world" />
                    <label data-localize="controls.destination.name" class="noselect">Destination:</label>
                    <input name="endWorld" type="text" class="js--world-input js--path--world-input js--end-world" />
                    <button data-localize="controls.reset.name" class="js--reset noselect">Reset</button>
                    <button data-localize="controls.help.name" class="js--help noselect">Help</button>
                </div>
            </div>
            <div id="graph" class="graph">
                <div class="loading-container">
                    <span class="loading-container__text loading-container__text--loading"><span data-localize="loading.label" class="loading-container__text__main">Loading</span><span data-localize="loading.space" class="loading-container__text__append">   </span></span>
                    <span class="loading-container__text loading-container__text--error" data-localize="loading.error" style="display: none;"></span>
                    <img src="images/urowalk.gif" />
                </div>
            </div>
            <div class="controls--container--tab">
                <button class="controls--container--tab__button noselect">▲</button>
            </div>
            <div class="controls--container controls-bottom--container">
                <div class="controls controls-bottom" style="opacity: 0;">
                    <div class="control">
                        <label data-localize="settings.lang.name" class="noselect">Language:</label>
                        <select name="language" class="js--lang">
                            <option data-localize="settings.lang.values.english" value="en" selected>English</option>
                            <option data-localize="settings.lang.values.japanese" value="ja">Japanese</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="settings.uiTheme.name" class="noselect">UI Theme:</label>
                        <select name="uiTheme" class="js--ui-theme">
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="settings.fontStyle.name" class="noselect">Font Style:</label>
                        <select name="fontStyle" class="js--font-style">
                            <option data-localize="settings.fontStyle.values.style1" value="0">Style 1</option>
                            <option data-localize="settings.fontStyle.values.style2" value="1">Style 2</option>
                            <option data-localize="settings.fontStyle.values.style3" value="2">Style 3</option>
                            <option data-localize="settings.fontStyle.values.style4" value="3">Style 4</option>
                            <option data-localize="settings.fontStyle.values.style5" value="4">Style 5</option>
                            <option data-localize="settings.fontStyle.values.style6" value="5">Style 6</option>
                            <option data-localize="settings.fontStyle.values.style7" value="6">Style 7</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="settings.renderMode.name" class="noselect">Render Mode:</label>
                        <select name="renderMode" class="js--render-mode">
                            <option data-localize="settings.renderMode.values.vertical" value="0" selected>2D</option>
                            <option data-localize="settings.renderMode.values.horizontal" value="1">3D</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="settings.displayMode.name" class="noselect">Display Mode:</label>
                        <select name="displayMode" class="js--display-mode">
                            <option data-localize="settings.displayMode.values.vertical" value="0" selected>Vertical</option>
                            <option data-localize="settings.displayMode.values.horizontal" value="1">Horizontal</option>
                            <option data-localize="settings.displayMode.values.radialIn" value="2">Inward</option>
                            <option data-localize="settings.displayMode.values.radialOut" value="3">Outward</option>
                            <option data-localize="settings.displayMode.values.free" value="4">Free</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="settings.connMode.name" class="noselect">Connection Mode:</label>
                        <select name="connMode" class="js--conn-mode">
                            <option data-localize="settings.connMode.values.oneWay" value="0" selected>One-Way</option>
                            <option data-localize="settings.connMode.values.twoWay" value="1">Two-Way</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="settings.labelMode.name" class="noselect">Label Display:</label>
                        <select name="labelMode" class="js--label-mode">
                            <option data-localize="settings.labelMode.values.never" value="0">Never</option>
                            <option data-localize="settings.labelMode.values.hover" value="1" selected>On Hover</option>
                            <option data-localize="settings.labelMode.values.select" value="2">On Select</option>
                            <option data-localize="settings.labelMode.values.always" value="3">Always</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="settings.sizeDiff.name" class="noselect">Size Difference:</label>
                        <input type="range" min="1" max="10" value="1" step="0.5" class="js--size-diff slider" />
                    </div>
                    <div class="control js--stack-size--container">
                        <label data-localize="settings.stackSize.name" class="noselect">Stack Threshold:</label>
                        <input type="range" min="5" max="100" value="20" step="1" class="js--stack-size slider" />
                    </div>
                </div>
            </div>
            <div data-localize="footer" class="footer noselect"></div>
            <script>
                $(document).keydown(function (event) {
                    if (event.which === 16)
                        isShift = true;
                    else if (event.which === 17)
                        isCtrl = true;
                });

                $(document).keyup(function (event) {
                    if (event.which === 16)
                        isShift = false;
                    else if (event.which === 17)
                        isCtrl = false;
                });

                let isShift = false;
                let isCtrl = false;
                let fontsLoaded = false;

                const worldScales = {};

                $.fn.extend({
                    animateCss: function (animation, duration, endCallback) {
                        const animationEnd = "webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend";
                        $(this).removeClass($(this).data("animateCss")).trigger("webkitAnimationEnd");
                        if (!duration)
                            duration = 250;
                        $(this).css({
                            "-webkit-animation-duration": duration + "ms",
                            "animation-duration": duration + "ms"
                        });
                        const classes = "animated " + animation;
                        $(this).data("animateCss", classes);

                        $(this).addClass(classes).one(animationEnd, function () {
                            $(this).off(animationEnd);
                            $(this).css({
                                "-webkit-animation-duration": "initial",
                                "animation-duration": "initial"
                            });
                            if (endCallback)
                                endCallback.apply(this);
                            $(this).removeClass(classes);
                        });

                        return this;
                    }
                });

                CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
                    if (width < 2 * radius) radius = width / 2;
                    if (height < 2 * radius) radius = height / 2;
                    this.moveTo(x + radius, y);
                    this.arcTo(x + width, y, x + width, y + height, radius);
                    this.arcTo(x + width, y + height, x, y + height, radius);
                    this.arcTo(x, y + height, x, y, radius);
                    this.arcTo(x, y, x + width, y, radius);
                    return this;
                };

                CanvasRenderingContext2D.prototype.emoji = function (x, y, scale, emoji) {
                    this.beginPath();
                    
                    switch (emoji) {
                        case "⛔":
                        case "🚫":
                            this.arc(x + 3.125 * scale, y - 2.1 * scale, 3.3 * scale, 0, 2 * Math.PI);
                            break;
                        case "🔒":
                        case "🔐":
                            const isCondition = emoji === "🔐";
                            this.roundRect(x - 0.21 * scale, y - 2.45 * scale, 5.4 * scale, 3.7 * scale, 0.5 * scale);
                            if (isCondition)
                                this.arc(x + 4.875 * scale, y - 3 * scale, 1.6 * scale, 0, 2 * Math.PI);
                            this.moveTo(x + 0.175 * scale, y - 2.445 * scale);
                            this.arc(x + 2.5 * scale, y - 3.1 * scale, 2.325 * scale, Math.PI, 0);
                            this.lineTo(x + 4.825 * scale, y - 2.445 * scale);
                            if (isCondition) {
                                this.moveTo(x + 5.65 * scale, y - 1.5825 * scale);
                                this.lineTo(x + 5.65 * scale, y + 0.525 * scale);
                                this.lineTo(x + 4.85 * scale, y + 1.2375 * scale);
                                this.lineTo(x + 4.85 * scale, y - 1.5825 * scale);
                            }
                            break;
                        case "🔑":
                            this.moveTo(x + 3.75 * scale, y - 2.9 * scale);
                            this.lineTo(x + 6.5 * scale, y - 0.15 * scale);
                            this.lineTo(x + 6.5 * scale, y + 1.2 * scale);
                            this.lineTo(x + 4.85 * scale, y + 1.2 * scale);
                            this.lineTo(x + 4.85 * scale, y + 0.6 * scale);
                            this.lineTo(x + 4.15 * scale, y + 0.6 * scale);
                            this.lineTo(x + 4.15 * scale, y);
                            this.lineTo(x + 3.5 * scale, y);
                            this.lineTo(x + 3.5 * scale, y - 0.6 * scale);
                            this.lineTo(x + 3.1 * scale, y - 0.6 * scale);
                            this.lineTo(x + 2.4 * scale, y - 1.4 * scale);
                            this.arc(x + 1.85 * scale, y - 3.35 * scale, 2.1 * scale, 0.4 * Math.PI, 2.4 * Math.PI)
                            break;
                        case "🚩":
                            this.moveTo(x - 0.05 * scale, y + 1.25 * scale);
                            this.lineTo(x - 0.05 * scale, y - 4.25 * scale);
                            this.arc(x + 0.475 * scale, y - 4.75 * scale, 0.725 * scale, 0.75 * Math.PI, 2.05 * Math.PI);
                            this.lineTo(x + 5.9 * scale, y - 3.1 * scale);
                            this.arc(x + 5.675 * scale, y - 2.775 * scale, 0.375 * scale, 1.5 * Math.PI, 0.4 * Math.PI);
                            this.lineTo(x + 1 * scale, y - 0.8 * scale);
                            this.lineTo(x + 1 * scale, y + 1.25 * scale);
                            break;
                        case "↩️":
                            this.rect(x - 0.2 * scale, y - 5.425 * scale, 6.675 * scale, 6.675 * scale);
                            break;
                        case "✨":
                            this.moveTo(x + 1.5 * scale, y - 2.64 * scale);
                            this.bezierCurveTo(x + 3.6 * scale, y - 2.15 * scale, x + 3.35 * scale, y - 4.7 * scale, x + 3.35 * scale, y - 4.7 * scale);
                            this.arc(x + 3.85 * scale, y - 4.8 * scale, 0.5 * scale, Math.PI, 2 * Math.PI);
                            this.bezierCurveTo(x + 4.05 * scale, y - 2.25 * scale, x + 6 * scale, y - 2.5 * scale, x + 6 * scale, y - 2.5 * scale);
                            this.arc(x + 6 * scale, y - 2 * scale, 0.5 * scale, 1.5 * Math.PI, 0.5 * Math.PI);
                            this.bezierCurveTo(x + 4.05 * scale, y - 1.75 * scale, x + 4.35 * scale, y + 0.7 * scale, x + 4.35 * scale, y + 0.7 * scale);
                            this.arc(x + 3.85 * scale, y + 0.8 * scale, 0.5 * scale, 0, Math.PI);
                            this.bezierCurveTo(x + 3.6 * scale, y - 1.75 * scale, x + 1.5 * scale, y - 1.5 * scale, x + 1.5 * scale, y - 1.5 * scale);
                            this.roundRect(x - 0.2 * scale, y - 3.35 * scale, 2.65 * scale, scale, 0.5 * scale);
                            this.roundRect(x + 0.6 * scale, y - 4.4 * scale, 1.05 * scale, 3.1 * scale, 0.5 * scale);
                            this.rect(x + 2.6 * scale, y - 1.2 * scale, 0.4 * scale, 0.4 * scale);
                            this.roundRect(x + 0.85 * scale, y - 0.85 * scale, 2.65 * scale, scale, 0.5 * scale);
                            this.roundRect(x + 1.65 * scale, y - 1.9 * scale, 1.05 * scale, 3.1 * scale, 0.5 * scale);
                            break;
                        case "🍀":
                            this.arc(x + 1 * scale, y - 3.325 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 2.125 * scale, y - 4.4 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 4.1 * scale, y - 4.4 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 5.225 * scale, y - 3.325 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 0.875 * scale, y - 1.375 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 1.975 * scale, y - 0.275 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 3.125 * scale, y + 0.7 * scale, 0.575 * scale, 0, 2 * Math.PI);
                            this.arc(x + 5.375 * scale, y - 1.375 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 4.225 * scale, y - 0.275 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.lineTo(x + 3.5 * scale, y + 0.85 * scale);
                            this.lineTo(x + 2 * scale, y + 0.85 * scale);
                            this.rect(x + 1.5 * scale, y - 3.5 * scale, 3.25 * scale, 4 * scale);
                            break;
                    }
                    this.closePath();
                };

                function hueToRGBA(h, a) {
                    let s = 1, v = 1, r, g, b, i, f, p, q, t;
                    i = Math.floor(h * 6);
                    f = h * 6 - i;
                    p = v * (1 - s);
                    q = v * (1 - f * s);
                    t = v * (1 - (1 - f) * s);
                    switch (i % 6) {
                        case 0: r = v, g = t, b = p; break;
                        case 1: r = q, g = v, b = p; break;
                        case 2: r = p, g = v, b = t; break;
                        case 3: r = p, g = q, b = v; break;
                        case 4: r = t, g = p, b = v; break;
                        case 5: r = v, g = p, b = q; break;
                    }
                    return "rgba(" + Math.round(r * 255) + "," + Math.round(g * 255) + "," + Math.round(b * 255) + "," + a + ")";
                }

                function getFontColor(fontStyle, callback) {
                    const uiTheme = config.uiTheme;
                    if (!uiThemeFontColors[uiTheme])
                        uiThemeFontColors[uiTheme] = {};
                    let pixel = uiThemeFontColors[uiTheme][fontStyle];
                    if (pixel)
                        return callback("rgba(" + pixel[0] + ", " + pixel[1] + ", " + pixel[2] + ", 1)");
                    const img = new Image();
                    img.onload = function () {
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        context.drawImage(img, 0, 0);
                        pixel = context.getImageData(0, 8, 1, 1).data;
                        uiThemeFontColors[uiTheme][fontStyle] = [ pixel[0], pixel[1], pixel[2] ];
                        callback("rgba(" + pixel[0] + ", " + pixel[1] + ", " + pixel[2] + ", 1)");
                        canvas.remove();
                    };
                    img.src = "./images/ui/" + config.uiTheme + "/font" + (fontStyle + 1) + ".png";
                }

                function getBaseBgColor(uiTheme, callback) {
                    const img = new Image();
                    let pixel = uiThemeBgColors[uiTheme];
                    if (pixel)
                        return callback("rgba(" + pixel[0] + ", " + pixel[1] + ", " + pixel[2] + ", 1)");
                    img.onload = function () {
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        context.drawImage(img, 0, 0);
                        pixel = context.getImageData(0, 0, 1, 1).data;
                        const pixel2 = context.getImageData(4, 4, 1, 1).data;
                        const pixel3 = context.getImageData(8, 8, 1, 1).data;
                        const r = Math.round((pixel[0] + pixel2[0] + pixel3[0]) / 3);
                        const g = Math.round((pixel[1] + pixel2[1] + pixel3[1]) / 3);
                        const b = Math.round((pixel[2] + pixel2[2] + pixel3[2]) / 3);
                        uiThemeBgColors[uiTheme] = [ r, g, b ];
                        callback("rgba(" + r + ", " + g + ", " + b + ", 1)");
                        canvas.remove();
                    };
                    img.src = "./images/ui/" + uiTheme + "/containerbg.png";
                }

                let worldData;

                function loadOrInitConfig() {
                    try {
                        if (!window.localStorage.hasOwnProperty("config")) {
                            window.localStorage.setItem("config", JSON.stringify(config));
                        } else {
                            const savedConfig = JSON.parse(window.localStorage.getItem("config"));
                            const configKeys = Object.keys(savedConfig);
                            for (let c in configKeys) {
                                const key = configKeys[c];
                                if (config.hasOwnProperty(key)) {
                                    const value = savedConfig[key];
                                    config[key] = value;
                                    switch (key) {
                                        case "lang":
                                            $(".js--lang").val(value);
                                            break;
                                        case "uiTheme":
                                            $(".js--ui-theme").val(value);
                                            break;
                                        case "fontStyle":
                                            $(".js--font-style").val(value);
                                            break;
                                        case "renderMode":
                                            $(".js--render-mode").val(value);
                                            break;
                                        case "displayMode":
                                            $(".js--display-mode").val(value);
                                            if (parseInt(value) >= 2)
                                                $(".js--stack-size--container").css("display", "none");
                                            break;
                                        case "connMode":
                                            $(".js--conn-mode").val(value);
                                            break;
                                        case "labelMode":
                                            $(".js--label-mode").val(value);
                                            break;
                                        case "sizeDiff":
                                            $(".js--size-diff").val(value);
                                            break;
                                        case "stackSize":
                                            $(".js--stack-size").val(value);
                                            break;
                                    }
                                }
                            }
                        }
                    } catch (error) {
                    }
                }

                function updateConfig() {
                    try {
                        window.localStorage.config = JSON.stringify(config);
                    } catch (error) {
                    }
                }

                function updateControlsContainer(updateTabMargin) {
                    const controlsHeight = $(".controls-top").outerHeight();
                    const settingsHeight = $(".controls-bottom").outerHeight();
                    $(".controls--container").css({ "height": settingsHeight + "px", "margin-top": "-" + (settingsHeight + 20) + "px" });
                    $(".controls--container--tab").css({ "height": settingsHeight + "px", "left": "calc(50% - " + (($(".controls--container--tab").outerWidth() - 16) / 2) + "px)" });
                    if (updateTabMargin && $(".controls-bottom").hasClass("visible"))
                        $(".controls--container--tab, .footer").css("margin-top", "-" + (settingsHeight + 8) + "px");
                    $(".js--help-modal").css({
                        "margin-top": (controlsHeight + 16) + "px",
                        "height": "calc(100% - " + (controlsHeight + 16 + ($(".controls-bottom").hasClass("visible") ? settingsHeight + 8 : 0)) + "px)"
                    });
                }

                function loadWorldData(update, success, fail) {
                    $.get("/worlds" + (update ? "?update=true" : ""), function (data) {
                        if (document.fonts.check("12px MS Gothic")) {
                            fontsLoaded = true;
                            success(data);
                        } else {
                            document.fonts.onloadingdone = e => fontsLoaded = true;
                            const fontsLoadedCheck = window.setInterval(function () {
                                if (fontsLoaded) {
                                    window.clearInterval(fontsLoadedCheck);
                                    success(data);
                                }
                            }, 100);
                        }
                    }).fail(fail);
                }

                let graph;
                
                let contextWorldId = null, startWorldId = null, endWorldId = null, selectedWorldId = null;

                let searchWorldIds = [], visibleWorldIds = [];
                
                let visibleTwoWayLinks = [];
                let visibleOneWayLinks = [];
                let linksTwoWayBuffered;
                let linksOneWayBuffered;

                let nodeObject;

                let icons3D;

                const colorLinkSelected = new THREE.Color('red');

                let iconLabel;

                let raycaster, mousePos = { x: 0, y: 0 };

                let localizedConns;

                let effectsJP;

                let uiThemeBgColors = {};

                let uiThemeFontColors = {};

                let config = {
                    lang: "en",
                    uiTheme: "Default_Custom",
                    fontStyle: 0,
                    renderMode: 0,
                    displayMode: 0,
                    connMode: 0,
                    labelMode: 1,
                    sizeDiff: 1,
                    stackSize: 20
                };

                function initGraph(renderMode, displayMode, paths) {

                    const is2d = !renderMode;

                    const links = [];

                    let dashOffset = 0;

                    const addedLinks = [];

                    const dagIgnore = {};

                    _.each(worldData, w => {
                        worldScales[w.id] = 1 + (Math.round((w.size - minSize) / (maxSize - minSize) * 10 * (config.sizeDiff - 1)) / 10);
                    });

                    const maxDepth =  _.max(worldData.map(w => w.depth));

                    if (paths) {
                        visibleWorldIds = _.uniq(_.flatten(paths).map(p => p.id));
                        const pathScores = [];
                        let minPathDepth = paths[0].length - 2;
                        let maxPathDepth;
                        let depthDiff;
                        let maxPathScore;
                        for (let pi in paths) {
                            const path = paths[pi];
                            if (path.length - 2 > minPathDepth * 2) {
                                let visibleWorldIdRemovalCandidates = _.uniq(_.flatten(paths.slice(pi)).map(p => p.id));
                                paths = paths.slice(0, pi);
                                let requiredWorldIds = _.uniq(_.flatten(paths).map(p => p.id));
                                _.remove(visibleWorldIdRemovalCandidates, w => requiredWorldIds.indexOf(w) > -1);
                                _.remove(visibleWorldIds, w => visibleWorldIdRemovalCandidates.indexOf(w) > -1);
                                break;
                            }
                            pathScores[pi] = parseInt(pi) + 3 * ((path.length - 2) - minPathDepth);
                        }
                        maxPathDepth = paths[paths.length - 1].length;
                        depthDiff = maxPathDepth - minPathDepth;
                        maxPathScore = ((paths.length - 1) + (3 * depthDiff)) * (depthDiff > 0 ? 1 : 2) || 1;
                        if (paths.length === 1 && paths[0][0].connType & ConnType.INACCESSIBLE)
                            pathScores[0] = maxPathScore;
                        for (let p in paths) {
                            const path = paths[p];
                            for (let w = 1; w < path.length; w++) {
                                const sourceId = path[w - 1].id;
                                const targetId = path[w].id;
                                const linkId = `${sourceId}_${targetId}`;
                                const hue = 0.6666 - ((pathScores[p] / maxPathScore) * 0.6666);
                                if (addedLinks.indexOf(linkId) === -1) {
                                    dagIgnore[sourceId] = [];
                                    const link = {
                                        key: linkId,
                                        source: sourceId,
                                        target: targetId,
                                        connType: path[w - 1].connType,
                                        typeParams: path[w - 1].typeParams,
                                        icons: [],
                                        hidden: false,
                                        defaultColor: hueToRGBA(hue, 1),
                                        defaultColorFade: hueToRGBA(hue, 0.1),
                                        connTypeCheck: 'replace'
                                    };
                                    links.push(link);
                                    addedLinks.push(linkId);
                                }
                            }
                        }
                    } else {
                        visibleWorldIds = Object.keys(worldData).map(id => parseInt(id));

                        for (let w in visibleWorldIds) {
                            const world = worldData[visibleWorldIds[w]];
                            const connections = world.connections;
                            const dagIgnoreIds = dagIgnore[world.id] = [];
                            for (let c in connections) {
                                const conn = connections[c];
                                const connWorld = worldData[conn.targetId];
                                let hidden = false;
                                if (conn.type & ConnType.NO_ENTRY)
                                    hidden = true;
                                else if (world.depth >= connWorld.depth) {
                                    const sameDepth = world.depth === connWorld.depth;
                                    const reverseConn = connWorld.connections.filter(c => c.targetId === world.id);
                                    hidden = (!sameDepth && !reverseConn.length) || (reverseConn.length && !(reverseConn[0].type & ConnType.NO_ENTRY) && (!sameDepth || (!(conn.type & ConnType.ONE_WAY) && world.id > connWorld.id)));
                                    if (!hidden)
                                        dagIgnoreIds.push(connWorld.id);
                                }
                                if (hidden)
                                    dagIgnoreIds.push(connWorld.id);
                                const hue = Math.max(0.6666 - ((world.depth / (maxDepth - 1)) * 0.6666), 0);
                                const link = {
                                    key: `${world.id}_${connWorld.id}`,
                                    source: world.id,
                                    target: connWorld.id,
                                    connType: conn.type,
                                    typeParams: conn.typeParams,
                                    icons: [],
                                    hidden: hidden,
                                    defaultColor: hueToRGBA(hue, 1),
                                    defaultColorFade: hueToRGBA(hue, 0.1),
                                    connTypeCheck: hidden ? 'after' : 'replace'
                                };
                                links.push(link);
                            }
                        }
                    }

                    initWorldSearch();

                    links.forEach(l => {
                        const icons = l.icons;
                        const connType = l.connType;
                        if (connType & ConnType.INACCESSIBLE)
                            icons.push(getConnTypeIcon(ConnType.INACCESSIBLE));
                        else {
                            if (connType & ConnType.ONE_WAY)
                                icons.push(getConnTypeIcon(ConnType.ONE_WAY));
                            else if (connType & ConnType.NO_ENTRY)
                                icons.push(getConnTypeIcon(ConnType.NO_ENTRY));
                            if (connType & ConnType.UNLOCK)
                                icons.push(getConnTypeIcon(ConnType.UNLOCK));
                            else if (connType & ConnType.LOCKED)
                                icons.push(getConnTypeIcon(ConnType.LOCKED));
                            else if (connType & ConnType.LOCKED_CONDITION)
                                icons.push(getConnTypeIcon(ConnType.LOCKED_CONDITION, l.typeParams[ConnType.LOCKED_CONDITION]));
                            if (connType & ConnType.DEAD_END)
                                icons.push(getConnTypeIcon(ConnType.DEAD_END));
                            else if (connType & ConnType.ISOLATED)
                                icons.push(getConnTypeIcon(ConnType.ISOLATED));
                            if (connType & ConnType.EFFECT)
                                icons.push(getConnTypeIcon(ConnType.EFFECT, l.typeParams[ConnType.EFFECT]));
                            if (connType & ConnType.CHANCE)
                                icons.push(getConnTypeIcon(ConnType.CHANCE, l.typeParams[ConnType.CHANCE]));
                        }
                    });

                    const images = (paths ? worldData.filter(w => visibleWorldIds.indexOf(w.id) > -1) : worldData)
                        .map(d => {
                            const img = new Image();
                            img.id = d.id;
                            img.title = config.lang === "en" || !d.titleJP ? d.title : d.titleJP;
                            img.src = d.filename;
                            return img;
                        });

                    const nodes = images.map(img => {
                        const id = parseInt(img.id);
                        const scale = worldScales[id];
                        const ret = { id: id, img, isHover: false, scale: scale };
                        ret.globalDepth = worldData[id].depth;
                        ret.dagIgnore = dagIgnore[id];
                        ret.width = 16 * scale;
                        ret.height = 12 * scale;
                        return ret;
                    });

                    const radius = 12;
                
                    const gData = {
                        nodes: nodes,
                        links: _.sortBy(links, l => {
                            const world = worldData[l.source];
                            return world.depth + (maxDepth + 1) * (l.connType & ConnType.ONE_WAY ? 1 : 0);
                        })
                    };

                    const lastLinkKey = gData.links[links.length - 1].key;

                    const oneWayLinks = gData.links.filter(l => !l.hidden && l.connType & ConnType.ONE_WAY);

                    const lastOneWayLinkKey = oneWayLinks.length ? oneWayLinks[oneWayLinks.length - 1].key : null;

                    let nodeDepths;

                    let depthDistances;

                    const dashLineSpeed = 20;

                    icons3D = [];

                    visibleTwoWayLinks = [];
                    visibleOneWayLinks = [];

                    linksBufferedLines = undefined;

                    let isWebGL2;

                    var canvas = document.createElement( 'canvas' );
                    var context = canvas.getContext( 'webgl2');
                    var rendererConfig;

                    if(context) {
                        isWebGL2 = true;
                        rendererConfig = {
                            antialias: true,
                            alpha: true,
                            canvas: canvas,
                            context: context
                        };
                    } else {
                        isWebGL2 = false;
                        rendererConfig = {
                            antialias: true,
                            alpha: true
                        };
                    }

                    const elem = document.getElementById('graph');

                    graph = Y2E.ForceGraph3D({
                        rendererConfig: rendererConfig,
                        controlType: 'orbit',
                        numDimensions: is2d ? 2 : 3
                    })(elem);

                    const maxAnisotropy = graph.renderer().capabilities.getMaxAnisotropy();

                    if (displayMode < 4)
                        graph = graph
                            .dagMode(displayMode === 0 ? 'td' : displayMode === 1 ? 'lr' : displayMode === 2 ? 'radialin' : 'radialout')
                            .dagLevelDistance(displayMode < 2 ? 12 : 24 + radius * (config.sizeDiff + 1));
                    const clock = new THREE.Clock();
                    let time = 0;

                    linksTwoWayBuffered = undefined;
                    linksOneWayBuffered = undefined;

                    graph = graph
                        .numDimensions(is2d ? 2 : 3)
                        .backgroundColor('#00000000')
                        .linkOpacity(1)
                        .nodeThreeObject(node => {
                            const scale = worldScales[node.id];
                            const world = worldData[node.id];
                            var ret;
                            const box = new THREE.BoxGeometry(13 * scale, 9.75 * scale, is2d ? 0.1 : 9.75 * scale);
                            var material;
                            if(isWebGL2) {
                                material = new THREE.MeshBasicMaterial();
                                material.visible = false;
                                ret = new THREE.Mesh(box, material);
                            } else {
                                const texture = new THREE.TextureLoader().load(world.filename);
                                texture.anisotropy = maxAnisotropy;
                                texture.minFilter = THREE.NearestFilter; // disables mipmaps (eliminates blur)
                                material = new THREE.MeshBasicMaterial({ map: texture });
                                ret = new THREE.Mesh(box, material);
                                ret.material.transparent = true;
                                if (is2d) {
                                    ret.material.depthTest = false;
                                    ret.renderOrder = world.id;
                                }

                                ret.material.opacity = getNodeOpacity(node);
                            }

                            const worldName = config.lang === "en" || !world.titleJP ? world.title : world.titleJP;
                            const text = new SpriteText(worldName, 1.5, 'white');
                            text.__graphObjType = 'label';
                            text.fontFace = 'MS Gothic';
                            text.fontSize = 80;
                            text.strokeWidth = is2d ? 1.5 : 2;
                            text.strokeColor = '#000000';
                            text.backgroundColor = false;
                            if (is2d) {
                                text.material.depthTest = false;
                                text.renderOrder = world.id;
                            } else {
                                text.borderWidth = 1;
                                text.borderColor = 'transparent';
                            }
                            
                            let textLines = worldName.split(" ");
                            for (let l = 0; l < textLines.length; l++) {
                                text.text = textLines[l];
                                if (text.scale.x * scale < 13 * scale) {
                                    let mergeIndex = 0;
                                    for (let l2 = l + 1; l2 < textLines.length; l2++) {
                                        const mergedLine = textLines.slice(l, l2 + 1).join(" ");
                                        text.text = mergedLine;
                                        if (text.scale.x * scale < 13 * scale)
                                            mergeIndex = l2;
                                        else
                                            break;
                                    }
                                    if (mergeIndex)
                                        textLines = textLines.slice(0, l).concat([textLines.slice(l, mergeIndex + 1).join(" ")], textLines.slice(mergeIndex + 1));
                                } else if (textLines[l].indexOf("：") > -1)
                                    textLines = textLines.slice(0, l).concat(textLines[l].replace(/：/g, "： ").split(" ")).concat(textLines.slice(l + 1));
                            }
                            text.text = textLines.join('\n');
                            text.defaultScale = { "x": text.scale.x, "y": text.scale.y };
                            text.material.transparent = true;
                            text.material.opacity = ret.material.opacity;
                            if (config.labelMode < 3)
                                text.visible = false;

                            ret.add(text);

                            return ret;
                        })
                        .onEngineTick(() => {
                            time -= clock.getDelta() * dashLineSpeed;
                            updateNodeLabels(is2d);
                            updateLinkObjects(visibleTwoWayLinks, linksTwoWayBuffered, is2d);
                            updateLinkObjects(visibleOneWayLinks, linksOneWayBuffered, is2d);
                            updateLinkAnimation(linksOneWayBuffered, time);
                            updateLinkDistances();
                            if(isWebGL2)
                                updateNodePositions(is2d);
                        })
                        .linkThreeObject(link => {
                            const dummy = new THREE.Points();
                            dummy.visible = false;
                            return dummy;
                        })
                        .linkPositionUpdate((linkObject, { start, end }, link) => {
                            if (icons3D[link.key] !== undefined) {
                                const linkIcons = icons3D[link.key];
                                const dist = is2d
                                    ? new THREE.Vector2(start.x, start.y).distanceTo(new THREE.Vector2(end.x, end.y))
                                    : new THREE.Vector3(start.x, start.y, start.z).distanceTo(new THREE.Vector3(end.x, end.y, end.z));
                                const spacing = Math.min(((dist / 2) / dist) / (linkIcons.length + 1), 16 / dist);
                                if (is2d) {
                                    for (let i in linkIcons) {
                                        const icon = linkIcons[i];
                                        let resX, resY;
                                        const rat = ((dist / 4) / dist) + i * spacing;
                                        resX = (1 - rat) * start.x + rat * end.x;
                                        resY = (1 - rat) * start.y + rat * end.y;
                                        icon.position.set(resX, resY, 0);
                                    }
                                } else {
                                    for (let i in linkIcons) {
                                        const icon = linkIcons[i];
                                        let resX, resY, resZ;
                                        const rat = ((dist / 4) / dist) + i * spacing;
                                        resX = (1 - rat) * start.x + rat * end.x;
                                        resY = (1 - rat) * start.y + rat * end.y;
                                        resZ = (1 - rat) * start.z + rat * end.z;
                                        icon.position.set(resX, resY, is2d ? 0 : resZ);
                                    }
                                }
                                if (link.connType & ConnType.ONE_WAY) {
                                    const oneWayIcon = linkIcons.filter(i => i.connType & ConnType.ONE_WAY)[0];
                                    oneWayIcon.material.map.repeat.x = link.source.x <= link.target.x ? 1 : -1;
                                }
                            }
                        })
                        .connMode(() => config.connMode)
                        .nodeVal(node => node.width)
                        .nodeLabel(node => node.img.title)
                        .nodesPerStack(config.stackSize)
                        .onNodeDragEnd(node => {
                            node.fx = node.x;
                            node.fy = node.y;
                            if (!is2d)
                                node.fz = node.z;
                        })
                        .onNodeHover((node, prevNode) => {
                            elem.style.cursor = node ? 'pointer' : null;
                            if (node)
                                node.isHover = true;
                            if (prevNode)
                                prevNode.isHover = false;
                        })
                        .onNodeClick(node => {
                            if (isCtrl || isShift)
                                openWorldWikiPage(node.id, isShift);
                            else {
                                const world = worldData[node.id];
                                if (node && (selectedWorldId == null || selectedWorldId !== node.id)) {
                                    $(".js--search-world").addClass("selected").val(config.lang === 'en' || !world.titleJP ? world.title : world.titleJP);
                                    selectedWorldId = node.id;
                                } else
                                    focusNode(node);
                                highlightWorldSelection();
                            }
                        })
                        .onNodeRightClick((node, ev) => {
                            contextWorldId = node.id;
                            $(".graph canvas").contextMenu({
                                x: ev.x,
                                y: ev.y
                            });
                        })
                        .onBackgroundClick(node => {
                            $(".js--search-world").removeClass("selected").val("");
                            selectedWorldId = null;
                            highlightWorldSelection();
                        })
                        .cooldownTime(Infinity)
                        // Deactivate existing forces
                        // Add collision and bounding box forces
                        .d3Force('collide', d3.forceCollide(node => radius * worldScales[node.id]))
                        .d3Force('box', () => {
                            const SQUARE_HALF_SIDE = radius * 50;

                            gData.nodes.forEach(node => {
                                const x = node.x || 0, y = node.y || 0;

                                // bounce on box walls
                                if (Math.abs(x) > SQUARE_HALF_SIDE) { node.vx += 0.1 * (x > 0 ? -1 : 1); }
                                if (Math.abs(y) > SQUARE_HALF_SIDE) { node.vy += 0.1 * (y > 0 ? -1 : 1); }

                                if (!is2d) {
                                    const z = node.z || 0;
                                    if (Math.abs(z) > SQUARE_HALF_SIDE) { node.vz += 0.1 * (z > 0 ? -1 : 1); }
                                }
                            });
                        })
                        .graphData(gData);

                    document.removeEventListener('mousemove', onDocumentMouseMove, false);
                    document.querySelector('#graph canvas').removeEventListener('wheel', clearTweens, false)

                    if (is2d) {
                        const controls = graph.controls();
                        controls.minAzimuthAngle = 0;
                        controls.maxAzimuthAngle = 0;
                        controls.mouseButtons.PAN = THREE.MOUSE.LEFT;
                        controls.mouseButtons.ORBIT = THREE.MOUSE.MIDDLE;
                        controls.enableRotate = false;
                        controls.update();
                    }

                     // when the mouse moves, call the given function
                     document.addEventListener('mousemove', onDocumentMouseMove, false);
                     document.querySelector('#graph canvas').addEventListener('wheel', clearTweens, false);

                    if(isWebGL2)
                        initNodeObject();

                    // initialize object to perform world/screen calculations
                    raycaster = new THREE.Raycaster();

                    graph.graphData().links.forEach(link => {
                        if (!link.hidden) {
                            if (link.connType & ConnType.ONE_WAY)
                                visibleOneWayLinks.push(link);
                            else
                                visibleTwoWayLinks.push(link);
                        }
                    })

                    makeLinkIcons(is2d);
                    makeLinkIconTooltip();
                    linksTwoWayBuffered = makeTwoWayLinkObjects(is2d);
                    linksOneWayBuffered = makeOneWayLinkObjects(is2d);
                    updateLinkObjects(visibleTwoWayLinks, linksTwoWayBuffered, is2d);
                    updateLinkObjects(visibleOneWayLinks, linksOneWayBuffered, is2d);
                    updateLinkColors(visibleTwoWayLinks, linksTwoWayBuffered);
                    updateLinkColors(visibleOneWayLinks, linksOneWayBuffered);
                }

                // START WEBGL2.0 SPECIFIC CODE
                function initNodeObject() {
                    const lineVertShader = `#version 300 es
                        precision highp float;
                        precision highp int;

                        uniform mat4 modelViewMatrix;
                        uniform mat4 projectionMatrix;
                        in mat4 instanceMatrix;
                        in vec3 position;
                        in vec3 normal;
                        in vec2 uv;

                        in float opacity;
                        out float vOpacity;
                        out vec2 vUv;
                        in float texIndex;
                        out float vTexIndex;
                        void main() {
                            vOpacity = opacity;
                            vUv = vec2(uv.x, 1.0 - uv.y); // flip texture vertically, because of how it's stored
                            vTexIndex = texIndex;
                            vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(position, 1.0);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `;
                    const lineFragShader = `#version 300 es
                        precision highp float;
                        precision highp int;
                        precision highp sampler2DArray;

                        in float vOpacity;
                        uniform sampler2DArray diffuse;
                        in vec2 vUv;
                        out vec4 fragmentColor;
                        in float vTexIndex;

                        void main() {
                            vec4 temp = texture(diffuse, vec3(vUv, int(vTexIndex)));
                            temp.a = vOpacity;
                            fragmentColor = temp;
                        }
                    `;

                    var nodeImgDimensions = {x: 320, y: 240};
                    const buffer = new ArrayBuffer(nodeImgDimensions.x * nodeImgDimensions.y * 4 * worldData.length);
                    var amount = graph.graphData().nodes.length;
                    var texture = new THREE.DataTexture2DArray(new Uint8ClampedArray(buffer), nodeImgDimensions.x, nodeImgDimensions.y, amount);
                    texture.format = THREE.RGBAFormat;
                    texture.type = THREE.UnsignedByteType;
                    const material = new THREE.RawShaderMaterial({
                        uniforms: {
                            diffuse: {value: texture },
                        },
                        vertexShader: lineVertShader,
                        fragmentShader: lineFragShader,
                        transparent: true
                    });

                    var opacities = [];
                    var texIndexes = [];
                    var i = 0;
                    for(i = 0; i < amount; i++) {
                        opacities[i] = 1.0;
                        texIndexes[i] = i;
                    }
                    var geometry = new THREE.BoxBufferGeometry(1, 1, 1);
                    geometry.attributes.opacity = new THREE.InstancedBufferAttribute(new Float32Array(opacities), 1);
                    geometry.attributes.texIndex = new THREE.InstancedBufferAttribute(new Float32Array(texIndexes), 1);

                    nodeObject = new THREE.InstancedMesh(geometry, material, amount);
                    nodeObject.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                    graph.scene().add(nodeObject);

                    var filenames = [];
                    graph.graphData().nodes.forEach(node => {
                         filenames.push(worldData[node.id].filename);
                    })

                    Promise.all(getImageRawData(filenames))
                    .then(images => {
                        var i = 0;
                        var canvas = document.createElement('canvas');
                        canvas.width = nodeImgDimensions.x;
                        canvas.height = nodeImgDimensions.y;
                        var context = canvas.getContext('2d');
                        images.forEach(img => {
                            // stretch to fit
                            context.drawImage( img, 0, 0, img.width, img.height,
                                                    0, 0, nodeImgDimensions.x, nodeImgDimensions.y);
                            var myData = context.getImageData(0, 0, nodeImgDimensions.x, nodeImgDimensions.y);
                            var offset = i * myData.data.length;
                            nodeObject.material.uniforms.diffuse.value.image.data.set(myData.data, offset);
                            i++;
                        })
                        delete canvas;
                        nodeObject.material.uniforms.diffuse.value.needsUpdate = true;
                    })
                    .catch(err => console.error(err))
                }

                function updateNodePositions(is2d) {
                    var dummy = new THREE.Object3D();
                    if(nodeObject) {
                        graph.graphData().nodes.forEach(node => {
                            nodeObject.getMatrixAt(node.id, dummy.matrix);
                            if(!is2d)
                                dummy.position.set(node.x, node.y, node.z);
                            else
                                dummy.position.set(node.x, node.y, 0);
                            var scale = worldScales[node.id];
                            dummy.scale.set(13 * scale, 9.75 * scale, is2d ? 0.1 : 9.75 * scale);
                            dummy.updateMatrix();
                            nodeObject.setMatrixAt(node.id, dummy.matrix);
                        });
                        nodeObject.instanceMatrix.needsUpdate = true;
                    }
                }
                // END WEBGL2.0 SPECIFIC CODE

                /**
                 *
                 * @param {Array} texturesSources - List of Strings that represent texture sources
                 * @returns {Array} Array containing a Promise for each source 
                 */
                function getImageRawData (imageSources) {
                    const loader = new THREE.ImageLoader()
                    return imageSources.map(imageSource => {
                        return new Promise((resolve, reject) => {
                            loader.load(
                                imageSource,
                                image => resolve(image),
                                undefined, // onProgress callback not supported from r84
                                err => reject(err)
                            )
                        })
                    })
                }

                function updateNodeLabels(is2d) {
                    if (config.labelMode > 0) {
                        const camera = graph.camera();
                        graph.graphData().nodes.forEach(node => {
                            const obj = node.__threeObj;
                            if (obj) {
                                const text = obj.children[0];
                                if (config.labelMode === 3 || (config.labelMode === 1 && node.isHover) || (config.labelMode === 2 && node.id === selectedWorldId)) {
                                    const scale = worldScales[node.id];
                                    if (!is2d) {
                                        const dist = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z).distanceTo(new THREE.Vector3(node.x, node.y, node.z));
                                        let resX, resY, resZ;
                                        const rat = (13 * scale) / dist;
                                        resX = (1 - rat) * node.x + rat * camera.position.x;
                                        resY = (1 - rat) * node.y + rat * camera.position.y;
                                        resZ = (1 - rat) * node.z + rat * camera.position.z;
                                        text.position.set(resX - node.x, resY - node.y, resZ - node.z);
                                    }
                                    text.scale.x = text.defaultScale.x * scale;
                                    text.scale.y = text.defaultScale.y * scale;
                                    text.material.opacity = getNodeOpacity(node);
                                    text.visible = true;
                                } else
                                    text.visible = false;
                            }
                        });
                    }
                }

                function getNodeOpacity(node) {
                    const id = node.id;
                    const opacity = (selectedWorldId == null || id === selectedWorldId) && (!searchWorldIds.length || searchWorldIds.indexOf(id) > -1)
                        ? 1
                        : selectedWorldId != null && worldData[selectedWorldId].connections.filter(c => c.targetId === id).length
                        ? 0.625
                        : 0.1;
                    return opacity;
                }

                function makeLinkIcons(is2d) {
                    graph.graphData().links.forEach(link => {
                        if (icons3D[link.key] === undefined) {
                            const linkOpacity = getLinkOpacity(link);
                            let linkIcons = [];
                            link.icons.forEach(icon => {
                                const text = new SpriteText(icon.char, 1, 'white');
                                text.__graphObjType = 'icon';
                                text.name = icon.text;
                                text.connType = icon.type;
                                text.fontFace = 'MS Gothic';
                                text.fontSize = 80;
                                text.borderWidth = 1;
                                text.borderColor = 'transparent';
                                if (is2d) {
                                    text.renderOrder = 0;
                                    text.material.depthTest = false;
                                }
                                text.material.transparent = true;
                                text.material.opacity = linkOpacity;
                                if (icon.type & ConnType.ONE_WAY) {
                                    text.material.map.wrapS = THREE.RepeatWrapping;
                                    link.source.x > link.target.x && (text.material.map.repeat.x = -1);
                                }
                                !config.connMode && link.hidden && (text.visible = false);
                                linkIcons.push(text);
                                graph.scene().add(text);
                            });
                            icons3D[link.key] = linkIcons;
                        }
                    });
                }

                function makeLinkIconTooltip() {
                    if (iconLabel) {
                        const element = document.getElementById("iconLabel");
                        element.parentNode.removeChild(element);
                    }
                    iconLabel = document.createElement('div');
                    iconLabel.innerHTML = ' ';
                    iconLabel.id = 'iconLabel';
                    iconLabel.className = "scene-tooltip";
                    iconLabel.style.position = 'absolute';
                    iconLabel.style.top = 0;
                    iconLabel.style.color = 'transparent';
                    iconLabel.style.zIndex = 10;
                    document.body.appendChild(iconLabel);
                }

                function makeTwoWayLinkObjects(is2d) {
                    const lineVertShader = `
                        attribute float opacity;
                        varying vec3 vColor;
                        varying float vOpacity;

                        void main() {
                            vColor = color;
                            vOpacity = opacity;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `;
                    const lineFragShader = `
                        varying vec3 vColor;
                        varying float vOpacity;

                        void main() {
                            gl_FragColor = vec4(vColor, vOpacity);
                        }
                    `;
                    const size = visibleTwoWayLinks.length;
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(size * 2 * 3), 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(size * 2 * 3), 3));
                    geometry.setAttribute('opacity', new THREE.BufferAttribute(new Float32Array(size * 2), 1));
                    const material = new THREE.ShaderMaterial({
                        vertexShader: lineVertShader,
                        fragmentShader: lineFragShader,
                        transparent: true,
                        vertexColors: true,
                        depthTest: !is2d
                    });
                    const bufferedGeometry = new THREE.LineSegments(geometry, material);
                    if (is2d)
                        bufferedGeometry.renderOrder = -1;
                    graph.scene().add(bufferedGeometry);
                    return bufferedGeometry;
                }

                function makeOneWayLinkObjects(is2d) {
                    const lineVertShader = `
                        attribute float lineDistance;
                        attribute float opacity;
                        varying float vLineDistance;
                        varying vec3 vColor;
                        varying float vOpacity;

                        void main() {
                            vColor = color;
                            vOpacity = opacity;
                            vLineDistance = lineDistance;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `;
                    const lineFragShader = `
                        uniform float time;

                        uniform float dashSize;
                        uniform float gapSize;
                        varying float vLineDistance;
                        varying vec3 vColor;
                        varying float vOpacity;

                        void main() {
                            float totalSize = dashSize + gapSize;
                            float modulo = mod(vLineDistance + time, totalSize);
                            if (modulo > dashSize) {
                                discard;
                            }
                            gl_FragColor = vec4(vColor, vOpacity);
                        }
                    `;
                    const size = visibleOneWayLinks.length;
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(size * 2 * 3), 3));
                    geometry.setAttribute('lineDistance', new THREE.BufferAttribute(new Float32Array(size * 2), 1));
                    geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(size * 2 * 3), 3));
                    geometry.setAttribute('opacity', new THREE.BufferAttribute(new Float32Array(size * 2), 1));
                    const material = new THREE.ShaderMaterial({
                        uniforms: {
                            dashSize: { value: 10 },
                            gapSize: { value: 10 },
                            time: { value: 0 }
                        },
                        vertexShader: lineVertShader,
                        fragmentShader: lineFragShader,
                        transparent: true,
                        vertexColors: true,
                        depthTest: !is2d
                    });
                    const bufferedGeometry = new THREE.LineSegments(geometry, material);
                    if (is2d)
                        bufferedGeometry.renderOrder = -1;
                    graph.scene().add(bufferedGeometry);
                    return bufferedGeometry;
                }

                function updateLinkObjects(linkData, bufferedObject, is2d) {
                    const positions = bufferedObject.geometry.attributes.position.array;
                    let index = 0;
                    linkData.forEach(link => {
                        let source, target;
                        if (link.source.x == undefined) {
                            source = { x: 0, y: 0, z: 0 };
                            target = { x: 0, y: 0, z: 0 };
                        } else {
                            source = link.source;
                            target = link.target;
                        }
                        positions[index++] = source.x;
                        positions[index++] = source.y;
                        positions[index++] = is2d ? 0 : source.z;
                        positions[index++] = target.x;
                        positions[index++] = target.y;
                        positions[index++] = is2d ? 0 : target.z;
                    })
                    bufferedObject.geometry.attributes.position.needsUpdate = true;
                    bufferedObject.geometry.computeBoundingSphere();
                }

                function updateLinkAnimation(bufferedObject, time) {
                    bufferedObject.material.uniforms.time.value = time;
                }

                function updateLinkColors(linkData, bufferedObject) {
                    const colors = bufferedObject.geometry.attributes.color.array;
                    const opacities = bufferedObject.geometry.attributes.opacity.array;
                    let index = 0;
                    let opacityIndex = 0;
                    linkData.forEach(link => {
                        let color;
                        let opacity;
                        const sourceId = link.source.id !== undefined ? link.source.id : link.source;
                        const targetId = link.target.id !== undefined ? link.target.id : link.target;
                        if (selectedWorldId != null && (selectedWorldId === sourceId || selectedWorldId === targetId)) {
                            opacity = 1.0;
                            color = colorLinkSelected;
                        } else if ((selectedWorldId == null || selectedWorldId === sourceId || selectedWorldId === targetId) && (!searchWorldIds.length || searchWorldIds.indexOf(sourceId) > -1 || searchWorldIds.indexOf(targetId) > -1)) {
                            opacity = 1.0;
                            color = new THREE.Color(link.defaultColor);
                        } else {
                            opacity = 0.1;
                            color = new THREE.Color(link.defaultColor);
                        }
                        colors[index++] = color.r;
                        colors[index++] = color.g;
                        colors[index++] = color.b;
                        colors[index++] = color.r;
                        colors[index++] = color.g;
                        colors[index++] = color.b;
                        opacities[opacityIndex++] = opacity;
                        opacities[opacityIndex++] = opacity;
                    });
                    bufferedObject.geometry.attributes.color.needsUpdate = true;
                    bufferedObject.geometry.attributes.opacity.needsUpdate = true;
                }

                function updateLinkDistances() {
                    const actual = linksOneWayBuffered.geometry.attributes.position.array;
                    let index = 3;
                    let d = 0;
                    for (let i = 0; i < visibleOneWayLinks.length * 2; i++) {
                        if ((i % 2)) {
                            const previousPoint = new THREE.Vector3(actual[index - 3], actual[index - 2], actual[index - 1]);
                            const currentPoint = new THREE.Vector3(actual[index++], actual[index++], actual[index++]);
                            d = currentPoint.distanceTo(previousPoint);
                            index += 3;
                        } else
                            d = 0;
                        linksOneWayBuffered.geometry.attributes.lineDistance.array[i] = d;
                    }
                    linksOneWayBuffered.geometry.attributes.lineDistance.needsUpdate = true;
                }

                function getLinkColor(link) {
                    const sourceId = link.source.id !== undefined ? link.source.id : link.source;
                    const targetId = link.target.id !== undefined ? link.target.id : link.target;
                    return link.hidden ? 'transparent' : selectedWorldId != null && (sourceId === selectedWorldId || selectedWorldId === targetId) ? '#f00' :
                        (selectedWorldId == null || selectedWorldId === sourceId || selectedWorldId === targetId) && (!searchWorldIds.length || searchWorldIds.indexOf(sourceId) > -1 || searchWorldIds.indexOf(targetId) > -1)
                        ? link.defaultColor : link.defaultColorFade;
                }

                function getLinkFaded(link) {
                    const sourceId = link.source.id !== undefined ? link.source.id : link.source;
                    const targetId = link.target.id !== undefined ? link.target.id : link.target;
                    return (selectedWorldId != null && sourceId !== selectedWorldId && selectedWorldId !== targetId) || (searchWorldIds.length && searchWorldIds.indexOf(sourceId) === -1 && searchWorldIds.indexOf(targetId) === -1);
                }

                function getLinkOpacity(link) {
                    const sourceId = link.source.id !== undefined ? link.source.id : link.source;
                    const targetId = link.target.id !== undefined ? link.target.id : link.target;
                    return (selectedWorldId == null || (selectedWorldId != null && (selectedWorldId === sourceId || selectedWorldId === targetId)))
                        && (!searchWorldIds.length || searchWorldIds.indexOf(sourceId) > -1 || searchWorldIds.indexOf(targetId) > -1)
                        ? 1
                        : selectedWorldId != null && (selectedWorldId === sourceId || selectedWorldId === targetId)
                        ? 0.625
                        : 0.1
                }

                function getConnTypeIcon(connType, typeParams) {
                    const localizedConn = localizedConns[connType];
                    const char = getConnTypeChar(connType);
                    const name = localizedConn.name;
                    let description = localizedConn.description;
                    if (description) {
                        switch (connType) {
                            case ConnType.EFFECT:
                                description = typeParams && ((config.lang === 'en' && typeParams.params) || (config.lang !== 'en' && typeParams.paramsJP))
                                    ? description.replace('{0}', config.lang === 'en' ? typeParams.params : typeParams.paramsJP)
                                    : null;
                                break;
                            case ConnType.CHANCE:
                                description = typeParams && typeParams.params
                                    ? description.replace('{0}', config.lang === 'en' ? typeParams.params : typeParams.params.replace('%', '％'))
                                    : '';
                                break;
                            case ConnType.LOCKED_CONDITION:
                                description = typeParams && ((config.lang === 'en' && typeParams.params) || (config.lang !== 'en' && typeParams.paramsJP))
                                    ? description.replace('{0}', config.lang === 'en' ? typeParams.params : typeParams.paramsJP)
                                    : '';
                                break;
                        }
                    }
                    return {
                        type: connType,
                        char: char,
                        text: name + (description ? (config.lang === 'en' ? ' - ' : '：') + description : '')
                    };
                }

                function getConnTypeChar(connType) {
                    let char;
                    switch (connType) {
                        case ConnType.ONE_WAY:
                            char = "➜";
                            break;
                        case ConnType.NO_ENTRY:
                            char = "⛔";
                            break;
                        case ConnType.UNLOCK:
                            char = "🔑";
                            break;
                        case ConnType.LOCKED:
                            char = "🔒";
                            break;
                        case ConnType.DEAD_END:
                            char = "🚩";
                            break;
                        case ConnType.ISOLATED:
                            char = "↩️";
                            break;
                        case ConnType.EFFECT:
                            char = "✨";
                            break;
                        case ConnType.CHANCE:
                            char = "🍀";
                            break;
                        case ConnType.LOCKED_CONDITION:
                            char = "🔐";
                            break;
                        case ConnType.INACCESSIBLE:
                            char = "🚫";
                            break;
                    }
                    return char;
                }

                function reloadGraph() {
                    const startWorld = startWorldId != null ? worldData[startWorldId] : null;
                    const endWorld = endWorldId != null ? worldData[endWorldId] : null;
                    const matchPaths = startWorld && endWorld && startWorld != endWorld
                        ? findPath(startWorld.id, endWorld.id, ConnType.NO_ENTRY | ConnType.DEAD_END | ConnType.ISOLATED)
                        : null;
                    if (graph)
                        graph._destructor();
                    initGraph(config.renderMode, config.displayMode, matchPaths);
                }

                let mult = 1;

                function findPath(s, t, ignoreTypeFlags) {
                    const startTime = performance.now();

                    const checkedSourceNodes = [s];
                    const checkedTargetNodes = [t];

                    const source = worldData[s];
                    const target = worldData[t];

                    let matchPaths = [];

                    let sourcePaths = {};
                    let targetPaths = {};

                    let nextGenSourceWorlds = [source];
                    let nextGenTargetWorlds = [target];

                    let genIndex = 0;

                    sourcePaths[s] = [{ id: s, connType: null }];
                    targetPaths[t] = [{ id: t, connType: null }];
                  
                    while (genIndex <= 20) {
                        let sourceWorlds = nextGenSourceWorlds.slice(0);
                        let targetWorlds = nextGenTargetWorlds.slice(0);
                        nextGenSourceWorlds = [];
                        nextGenTargetWorlds = [];
                        for (let sw in sourceWorlds) {
                            const sourceWorld = sourceWorlds[sw];
                            const sourcePath = sourcePaths[sourceWorld.id];
                            //delete sourcePaths[sourceWorld.id];
                            const sourceConns = traverseConns(checkedSourceNodes, sourcePath, nextGenSourceWorlds, sourceWorld, ignoreTypeFlags, true);
                            $.extend(sourcePaths, sourceConns);
                        }
                        for (let tw in targetWorlds) {
                            const targetWorld = targetWorlds[tw];
                            const targetPath = targetPaths[targetWorld.id];
                            //delete targetPaths[targetWorld.id];
                            const targetConns = traverseConns(checkedTargetNodes, targetPath, nextGenTargetWorlds, targetWorld, ignoreTypeFlags, false);
                            $.extend(targetPaths, targetConns);
                        }
                        
                        genIndex++;

                        /*let checkedSourceIds = Object.keys(sourcePaths).map(id => parseInt(id));
                        let checkedTargetIds = Object.keys(targetPaths).map(id => parseInt(id));*/

                        $.grep(checkedSourceNodes, id => {
                            const ret = $.inArray(id, checkedTargetNodes) !== -1;
                            if (ret) {
                                let skip = false;

                                let sourcePath = _.cloneDeep(sourcePaths[id]);
                                let targetPath = _.cloneDeep(targetPaths[id]);

                                if (sourcePath[sourcePath.length - 1].id === id && targetPath[targetPath.length - 1].id === id) {
                                    sourcePath = sourcePath.slice(0, -1);
                                }

                                let loopWorldIds, sourcePathIds, targetPathIds;
                                while ((loopWorldIds = _.intersectionWith((sourcePathIds = sourcePath.map(sp => sp.id)), (targetPathIds = targetPath.map(tp => tp.id)), _.isEqual)).length) {
                                    //console.log("Loop found", worldData[loopWorldIds[0]].title, JSON.stringify(sourcePath.map(function(p) { return worldData[p].title})), JSON.stringify(targetPath.map(function(p) { return worldData[p].title})));
                                    sourcePath = sourcePath.slice(0, sourcePathIds.indexOf(loopWorldIds[0]));
                                    targetPath = targetPath.slice(0, targetPathIds.indexOf(loopWorldIds[0]) + 1);
                                    //console.log("Loop fixed", worldData[loopWorldIds[0]].title, JSON.stringify(sourcePath.map(function(p) { return worldData[p].title})), JSON.stringify(targetPath.map(function(p) { return worldData[p].title})));
                                }
                                
                                const matchPath = sourcePath.concat(targetPath.reverse());
                                for (let p in matchPaths) {
                                    for (let w = 1; w < matchPaths[p].length; w++) {
                                        const linkId = `${matchPaths[p][w - 1].id}_${matchPaths[p][w].id}`;
                                        for (let m = 1; m < matchPath.length; m++) {
                                            const matchLinkId = `${matchPath[m - 1].id}_${matchPath[m].id}`;
                                            if (linkId === matchLinkId) {
                                                skip = true;
                                                break;
                                            }
                                        }
                                        if (skip)
                                            break;
                                    }
                                    if (skip)
                                        break;
                                }
                                if (skip)
                                    return false;
                                _.remove(nextGenSourceWorlds, w => w.id === id);
                                _.remove(nextGenTargetWorlds, w => w.id === id);
                                matchPaths.push(matchPath);
                            }
                            return ret;
                        });
                    }

                    const endTime = performance.now();

                    console.log("Found", matchPaths.length, "matching path(s) in", Math.round((endTime - startTime) * 10) / 10, "ms");

                    if (!matchPaths.length) {
                        if (ignoreTypeFlags & ConnType.DEAD_END)
                            ignoreTypeFlags ^= (ConnType.DEAD_END | ConnType.ISOLATED);
                        else
                            ignoreTypeFlags = 0;
                        if (ignoreTypeFlags)
                            return findPath(s, t, ignoreTypeFlags);
                        else {
                            matchPaths = [ [ { id: s, connType: ConnType.INACCESSIBLE }, { id: t, connType: null } ] ];
                            return matchPaths;
                        }
                    } else {
                        if ((!(ignoreTypeFlags & ConnType.LOCKED) && _.every(matchPaths, mp => mp.filter(p => p.connType && p.connType & (ConnType.LOCKED | ConnType.LOCKED_CONDITION).length)))) {
                            const additionalPaths = findPath(s, t, (ignoreTypeFlags = ignoreTypeFlags | ConnType.LOCKED | ConnType.LOCKED_CONDITION));
                            if (additionalPaths.length && !(additionalPaths[0][0].connType & ConnType.INACCESSIBLE)) {
                                for (let ap in additionalPaths)
                                    matchPaths.push(additionalPaths[ap]);
                            }
                        }
                        matchPaths = _.sortBy(matchPaths, [ 'length' ]);
                        if (matchPaths.length > 5)
                            matchPaths = matchPaths.slice(0, 5);
                    }

                    return matchPaths;
                }

                function traverseConns(checkedNodes, path, nextGenWorlds, world, ignoreTypeFlags, isSource) {
                    const ret = {};
                    const conns = world.connections;
                    for (let c in conns) {
                        let connType = conns[c].type;
                        const typeParams = conns[c].typeParams;
                        if (isSource && connType & ignoreTypeFlags)
                            continue;
                        const connWorld = worldData[conns[c].targetId];
                        const id = connWorld.id;
                        if (checkedNodes.indexOf(id) === -1) {
                            // If checking from target
                            if (isSource) {
                                path[path.length - 1].connType = connType;
                                path[path.length - 1].typeParams = typeParams;
                                connType = null;
                            } else {
                                const reverseConn = connWorld.connections.filter(c => c.targetId === world.id);
                                let reverseConnType = 0;
                                if (reverseConn.length)
                                    reverseConnType = reverseConn[0].type;
                                else {
                                    if (connType & ConnType.ONE_WAY)
                                        reverseConnType |= ConnType.NO_ENTRY;
                                    else if (connType & ConnType.NO_ENTRY)
                                        reverseConnType |= ConnType.ONE_WAY;
                                    if (connType & ConnType.LOCKED)
                                        reverseConnType |= ConnType.UNLOCK;
                                    else if (connType & ConnType.UNLOCK)
                                        reverseConnType |= ConnType.LOCKED;
                                    if (connType & ConnType.DEAD_END)
                                        reverseConnType |= ConnType.ISOLATED;
                                    else if (connType & ConnType.ISOLATED)
                                        reverseConnType |= ConnType.DEAD_END;
                                }
                                connType = reverseConnType;
                                if (connType & ignoreTypeFlags)
                                    continue;
                            }
                            const connPath = path.slice(0);
                            connPath.push({
                                id: id,
                                connType: connType,
                                typeParams: typeParams
                            });
                            ret[id] = connPath;
                            checkedNodes.push(id);
                            nextGenWorlds.push(worldData[id]);
                        }
                    }
                    return ret;
                }

                function findConnectionAnomalies() {
                    const connData = {};
                    worldData.forEach(w => {
                        connData[w.id] = [];
                        worldData[w.id].connections.map(c => worldData[c.targetId]).forEach(c => {
                            connData[w.id].push(c.id);
                        });
                    }); 
                    Object.keys(connData).forEach(id => {
                        let connIds = connData[id].slice(0);
                        connIds.forEach(c => {
                            const index = connData[c].indexOf(parseInt(id));
                            if (index > -1) {
                                connData[id].splice(connData[id].indexOf(c), 1);
                                connData[c].splice(index, 1);
                            }
                        });
                    });
                    Object.keys(connData).forEach(id => {
                        if (connData[id].length) {
                            connData[id].forEach(c => {
                                console.log(worldData[c].title, "is missing a connection to", worldData[id].title);
                            });
                        }
                    });
                }

                function initLocalization(isInitial) {
                    const isEn = config.lang === "en";

                    $("[data-localize]").localize("ui", {
                        language: config.lang,
                        pathPrefix: "/lang",
                        callback: function (data, defaultCallback) {
                            data.footer = data.footer.replace("{VERSION}", "2.2.1");
                            localizedConns = data.conn;
                            initContextMenu(data.contextMenu);
                            if (isInitial) {
                                Object.keys(data.settings.uiTheme.values).forEach(t => {
                                    $(".js--ui-theme").append('<option data-localize="settings.uiTheme.values.' + t + '" value="' + t + '">' + data.settings.uiTheme.values[t] + '</option>');
                                });
                                $(".js--ui-theme").val(config.uiTheme).change();
                            }
                            window.setTimeout(() => updateControlsContainer(true), 0);
                            defaultCallback(data);
                        }
                    });

                    $(".js--help-modal__content--localized--en").toggle(isEn);
                    $(".js--help-modal__content--localized--jp").toggle(!isEn);

                    $.localize("conn", {
                        language: config.lang,
                        pathPrefix: "/lang",
                        callback: function (data) {
                            localizedConns = data;
                        }
                    });

                    if (isInitial) {
                        $.localize("effect", {
                            language: 'ja',
                            pathPrefix: "/lang",
                            callback: function (data) {
                                effectsJP = data;
                            }
                        });
                    }

                    $(".js--world-input").each(function() {
                        const val = $(this).val();
                        if (val && worldNames.indexOf(val) > -1) {
                            const world = worldsByName[worldNames[worldNames.indexOf(val)]];
                            $(this).val(isEn || !world.titleJP ? world.title : world.titleJP);
                        }
                    });

                    worldsByName = isEn ? _.keyBy(worldData, w => w.title) : _.keyBy(worldData, w => w.titleJP || w.title);

                    worldNames = Object.keys(worldsByName);

                    $(".js--path--world-input").each(function () {
                        $(this).off("change").autocomplete("destroy");
                        $(this).on("change", function () {
                            const currentWorldId = $(this).is(".js--start-world") ? startWorldId : endWorldId;
                            const currentWorld = worldData[currentWorldId];
                            if (currentWorld != null && $(this).val() !== (config.lang === 'en' || !currentWorld.titleJP ? currentWorld.title : currentWorld.titleJP)) {
                                let isReloadGraph;
                                $(this).removeClass("selected");
                                if ($(this).is(".js--start-world")) {
                                    isReloadGraph = endWorldId != null && endWorldId !== startWorldId;
                                    startWorldId = null;
                                } else {
                                    isReloadGraph = startWorldId != null && startWorldId !== endWorldId;
                                    endWorldId = null;
                                }
                                if (isReloadGraph)
                                    reloadGraph();
                            }
                        }).autocomplete({
                            lookup: worldNames,
                            triggerSelectOnValidInput: false,
                            onSelect: function (selectedWorld) {
                                let isReloadGraph;
                                const worldId = worldsByName[selectedWorld.value].id;
                                $(this).addClass("selected");
                                if ($(this).is(".js--start-world")) {
                                    startWorldId = worldId;
                                    isReloadGraph = endWorldId != null && endWorldId !== startWorldId;
                                } else {
                                    endWorldId = worldId;
                                    isReloadGraph = startWorldId != null && startWorldId !== endWorldId;
                                }
                                if (isReloadGraph)
                                    reloadGraph();
                            }
                        });
                    });
                }

                function initWorldSearch() {
                    const $search = $(".js--search-world");
                    $search.autocomplete("destroy");
                    const visibleWorldNames = worldData ? worldData.filter(w => visibleWorldIds.indexOf(w.id) > -1).map(w => config.lang === 'en' || !w.titleJP ? w.title : w.titleJP) : [];
                    if (selectedWorldId != null && visibleWorldIds.indexOf(selectedWorldId) === -1) {
                        $search.removeClass("selected").val("");
                        selectedWorldId = null;
                    }
                    $search.autocomplete({
                        lookup: visibleWorldNames,
                        triggerSelectOnValidInput: false,
                        onSearchComplete: function (query, searchWorlds) {
                            const selectedWorld = selectedWorldId != null ? worldData[selectedWorldId] : null;
                            const selectedWorldName = selectedWorld ? config.lang === 'en' || !selectedWorld.titleJP ? selectedWorld.title : selectedWorld.titleJP : null;
                            searchWorldIds = searchWorlds.length && (!selectedWorld || (searchWorlds.length > 1 || searchWorlds.filter(w => w.value !== selectedWorldName).length)) ? searchWorlds.map(w => worldsByName[w.value].id) : [];
                            if (searchWorldIds.length && selectedWorld && (searchWorldIds.length !== 1 || selectedWorldId !== searchWorldIds[0])) {
                                $search.removeClass("selected");
                                selectedWorldId = null;
                            }
                            highlightWorldSelection();
                        },
                        onSelect: function (selectedWorld) {
                            $search.addClass("selected");
                            selectedWorldId = worldsByName[selectedWorld.value].id;
                            focusNode(graph.graphData().nodes[selectedWorldId]);
                            highlightWorldSelection();
                        },
                        onHide: function () {
                           if (selectedWorldId != null) {
                                const selectedWorld = worldData[selectedWorldId];
                                const selectedWorldName = config.lang === 'en' || !selectedWorld.titleJP ? selectedWorld.title : wselectedWorld.titleJP;
                                if ($(this).val() !== selectedWorldName) {
                                    $search.removeClass("selected");
                                    selectedWorldId = null;
                                }
                            }
                            searchWorldIds = [];
                            highlightWorldSelection();
                        }
                    });
                }

                function initContextMenu(localizedContextMenu) {
                    $.contextMenu('destroy');
                    $.contextMenu({
                        selector: '.graph canvas', 
                        trigger: 'none',
                        items: {
                            "wiki": {
                                name: () => localizedContextMenu.items.wiki,
                                callback: () => openWorldWikiPage(contextWorldId)
                            },
                            "start": {
                                name: () => localizedContextMenu.items.start,
                                callback: function () {
                                    const world = worldData[contextWorldId];
                                    const worldName = config.lang === 'en' || !world.titleJP ? world.title : world.titleJP;
                                    $(".js--start-world").val(worldName).change().autocomplete().select(0);
                                }
                            },
                            "end": {
                                name: () => localizedContextMenu.items.end,
                                callback: function () {
                                    const world = worldData[contextWorldId];
                                    const worldName = config.lang === 'en' || !world.titleJP ? world.title : world.titleJP;
                                    $(".js--end-world").val(worldName).change().autocomplete().select(0);
                                }
                            }
                        }
                    });
                }

                function openWorldWikiPage(worldId, newWindow) {
                    const world = worldData[worldId];
                    window.open(config.lang === 'en' || !world.titleJP
                        ? 'https://yume2kki.fandom.com/wiki/' + world.title
                        : ('https://wikiwiki.jp/yume2kki-t/' + (world.titleJP.indexOf("：") > -1 ? world.titleJP.slice(0, world.titleJP.indexOf("：")) : world.titleJP)),
                        "_blank", newWindow ? "width=" + window.outerWidth + ",height=" + window.outerHeight : "");
                }

                function focusNode(node) {
                    const scale = worldScales[node.id];
                    const distance = 50 * scale;
                    if (!config.renderMode) {
                        const camera = graph.camera();
                        graph.cameraPosition({ x: node.x, y: node.y, z: distance }, node, 1000);
                        const oldZoom = { zoom: camera.zoom };
                        const newZoom = { zoom: 20 / scale };
                        new Y2E.TWEEN.Tween(oldZoom).to(newZoom, graph.controls().zoomSpeed * 1000).easing(Y2E.TWEEN.Easing.Quadratic.Out).onUpdate(zoom => {
                            camera.zoom = zoom.zoom;
                            camera.updateProjectionMatrix();
                        }).start();
                    } else {
                        const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
                        graph.cameraPosition({ x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }, node, 1000);
                    }
                }

                function updateConnectionModeIcons() {
                    graph.graphData().links.forEach(link => {
                        if (icons3D[link.key] !== undefined) {
                            const linkOpacity = getLinkOpacity(link);
                            icons3D[link.key].forEach(icon => {
                                icon.visible = true;
                                icon.material.opacity = linkOpacity;
                                config.connMode === 0 && link.hidden && (icon.visible = false);
                            });
                        }
                    });
                }

                function highlightWorldSelection() {
                    updateConnectionModeIcons();
                    graph.graphData().nodes.forEach(node => {
                        if(nodeObject)
                            nodeObject.geometry.attributes.opacity.array[node.id] = getNodeOpacity(node);
                        else {
                            node.__threeObj.material.opacity = getNodeOpacity(node)
                        }
                    });
                    if(nodeObject)
                        nodeObject.geometry.attributes.opacity.needsUpdate = true;
                    updateLinkColors(visibleTwoWayLinks, linksTwoWayBuffered);
                    updateLinkColors(visibleOneWayLinks, linksOneWayBuffered);
                }

                let worldsByName, worldNames, minSize, maxSize;

                function onDocumentMouseMove(event) {
                    updateRaycast();
                    // update the mouse variable
                    mousePos.clientX = event.clientX;
                    mousePos.clientY = event.clientY;
                    mousePos.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mousePos.y = -(event.clientY / window.innerHeight) * 2 + 1;
                }

                function clearTweens() {
                    Y2E.TWEEN._tweens = {};
                }

                function updateRaycast() {
                    const vector = new THREE.Vector3(mousePos.x, mousePos.y, 1);
                    let intersects = [];

                    if (!$(".js--help-modal:visible").length) {
                        raycaster.setFromCamera(vector, graph.camera());
                        // create an array containing all objects in the scene with which the ray intersects
                        intersects = raycaster.intersectObjects(graph.graphData().nodes.map(node => node.__threeObj).filter(o => o).concat(graph.scene().children.filter(o => o.__graphObjType === 'icon' && o.visible)));
                    }

                    // if there are one or more intersections
                    if (intersects.length)
                    {
                        const topObj = intersects[0];
                        if (topObj.object.__graphObjType !== "node") {
                            $(".graph .scene-tooltip").css("visibility", "hidden"); 
                            // update text, if it has a "name" field.
                            if (topObj.object.name) {
                                const viewPortCoords = {
                                    x: mousePos.clientX,
                                    y: mousePos.clientY
                                };
                                iconLabel.innerHTML = intersects[0].object.name;
                                iconLabel.style.left = viewPortCoords.x + (mousePos.x + 1) * iconLabel.offsetWidth * -0.5;
                                iconLabel.style.top = viewPortCoords.y + 21;
                            }
                            return;
                        }
                    }
                    iconLabel.innerHTML = '';
                    $(".graph .scene-tooltip").css("visibility", "visible");
                }

                function openHelpModal() {
                    $(".js--help-modal").modal({
                        fadeDuration: 100,
                        closeClass: 'noselect',
                        closeText: '✖'
                    });
                }

                $(document).ready(function () {
                    let loadingFrameCount = 0;
                    const loadingTimer = window.setInterval(function () {
                        let loadingTextAppend = "";
                        const loadingTextAppendChar = config.lang === "en" ? "." : "．";
                        const loadingTextSpaceChar = config.lang === "en" ? " " : "　";
                        for (let i = 0; i < 3; i++)
                            loadingTextAppend += i < loadingFrameCount ? loadingTextAppendChar : loadingTextSpaceChar;
                        $(".loading-container__text__append").text(loadingTextAppend);
                        loadingFrameCount += loadingFrameCount < 3 ? 1 : -3;
                    }, 300);
                    
                    $(".controls--container--tab__button").click(function() {
                        if ($(".controls-bottom").hasClass("visible")) {
                            $(".controls-bottom").removeClass("visible").animateCss("slideOutDown", 250, function () {
                                if (!$(this).hasClass("visible"))
                                    $(this).css("opacity", 0);
                            });
                            $(".controls--container--tab, .footer").css("margin-top", "0px").animateCss("slideInDown", 300);
                        } else {
                            $(".controls-bottom").addClass("visible").css("opacity", 1).animateCss("slideInUp", 250);
                            $(".controls--container--tab, .footer").css("margin-top", "-" + ($(".controls-bottom").outerHeight() + 8) + "px").animateCss("slideInUp", 250);
                        }
                        updateControlsContainer();
                    });

                    updateControlsContainer(true);
                    $(window).resize(updateControlsContainer).blur(function() {
                        isShift = false;
                        isCtrl = false;
                    });
                    
                    $(".js--lang").change(function() {
                        config.lang = $(this).val();
                        updateConfig();
                        initLocalization();
                        if (worldData)
                            reloadGraph();
                    });

                    $(".js--ui-theme").change(function() {
                        config.uiTheme = $(this).val();
                        const themeStyles = $(".js--theme-styles")[0];
                        getBaseBgColor(config.uiTheme || (config.uiTheme = "Default_Custom"), function (color) {
                            const bgColorPixel = uiThemeBgColors[config.uiTheme];
                            const altColor = "rgba(" + Math.min(bgColorPixel[0] + 48, 255) + ", " + Math.min(bgColorPixel[1] + 48, 255) + ", " + Math.min(bgColorPixel[2] + 48, 255) + ", 1)";
                            themeStyles.textContent = themeStyles.textContent.replace(/url\(\/images\/ui\/[a-zA-Z0-9\_]+\/(containerbg|border(?:2)?|font\d)\.png\)/g, "url(/images/ui/" + config.uiTheme + "/$1.png)")
                                .replace(/background-color:( *)[^;!]*(!important)?;( *)\/\*base\*\//g, "background-color:$1" + color + "$2;$3/*base*/")
                                .replace(/background-color:( *)[^;!]*(!important)?;( *)\/\*alt\*\//g, "background-color:$1" + altColor + "$2;$3/*alt*/");
                            $(".js--font-style").change();
                            updateConfig();
                        });
                    });

                    $(".js--font-style").change(function() {
                        config.fontStyle = parseInt($(this).val());
                        const themeStyles = $(".js--theme-styles")[0];
                        getFontColor(config.fontStyle, function (baseColor) {
                            getFontColor(config.fontStyle !== 4 ? 4 : 0, function (altColor) {
                                themeStyles.textContent = themeStyles.textContent = themeStyles.textContent.replace(/url\(\/images\/ui\/([a-zA-Z0-9\_]+)\/font\d\.png\)/g, "url(/images/ui/$1/font" + (config.fontStyle + 1) + ".png)")
                                    .replace(/([^\-])color:( *)[^;!]*(!important)?;( *)\/\*base\*\//g, "$1color:$2" + baseColor + "$3;$4/*base*/")
                                    .replace(/([^\-])color:( *)[^;!]*(!important)?;( *)\/\*alt\*\//g, "$1color:$2" + altColor + "$3;$4/*alt*/");
                                updateConfig();
                            });
                        });
                    });

                    $(".js--render-mode").change(function() {
                        config.renderMode = parseInt($(this).val());
                        updateConfig();
                        if (worldData)
                            reloadGraph();
                    });

                    $(".js--display-mode").change(function() {
                        config.displayMode = parseInt($(this).val());
                        updateConfig();
                        if (worldData)
                            reloadGraph();
                        $(".js--stack-size--container").css("display", config.displayMode < 2 ? "flex" : "none");
                    });

                    $(".js--conn-mode").change(function() {
                        config.connMode = parseInt($(this).val());
                        updateConnectionModeIcons();
                        updateConfig();
                    });

                    $(".js--label-mode").change(function() {
                        config.labelMode = parseInt($(this).val());
                        if (!config.labelMode) {
                            graph.graphData().nodes.forEach(node => {
                                const obj = node.__threeObj;
                                if (obj)
                                    obj.children[0].visible = false;
                            });
                        }
                        updateConfig();
                    });

                    $(".js--size-diff").change(function() {
                        config.sizeDiff = parseFloat($(this).val());
                        updateConfig();
                        if (worldData)
                            reloadGraph();
                    });

                    $(".js--stack-size").change(function() {
                        config.stackSize = parseInt($(this).val());
                        updateConfig();
                        if (worldData)
                            reloadGraph();
                    });

                    $(".js--reset").click(function() {
                        $(".js--world-input").removeClass("selected").val("");
                        startWorldId = null;
                        endWorldId = null;
                        selectedWorldId = null;
                        if (worldData)
                            reloadGraph();
                    });

                    $(".js--help").click(function() {
                        if ($(".js--help-modal:visible").length)
                            $.modal.close();
                        else if ($(".js--help-modal__content--localized").text())
                            openHelpModal();
                        else {
                            $.get("/help", function (data) {
                                const md = new Remarkable();
                                data = data.split('---');
                                const helpEn = md.render(data[0]);
                                const helpJp = data.length > 1 ? md.render(data[1]) : helpEn;
                                $('.js--help-modal__content--localized').html('<div class="js--help-modal__content--localized--en"' + (config.lang === 'en' ? '' : ' style="display: none;"') + '>' + helpEn + '</div>'
                                    + '<div class="js--help-modal__content--localized--jp"' + (config.lang === 'en' ? ' style="display: none;"' : '') + '>' + helpJp + '</div>');
                                openHelpModal();
                            });
                        }
                    })

                    loadOrInitConfig();

                    initLocalization(true);

                    loadWorldData(false, function (data) {
                        worldData = data;

                        for (let d in Object.keys(worldData)) {
                            const world = worldData[d];
                            world.id = parseInt(d);
                            world.connections.forEach(conn => {
                                const effectParams = conn.typeParams[ConnType.EFFECT];
                                if (effectParams) {
                                    effectParams.paramsJP = effectParams.params.split(',').map(e => effectsJP[e]).join('」か「');
                                    effectParams.params = effectParams.params.replace(/,/g, ', ');
                                }
                            });
                        }

                        initLocalization();

                        const worldSizes = worldData.map(w => w.size); 

                        minSize = _.min(worldSizes);
                        maxSize = _.max(worldSizes);

                        window.clearInterval(loadingTimer);

                        reloadGraph();
                    }, function () {
                        window.clearInterval(loadingTimer);
                        $(".loading-container .loading-container__text--loading").hide();
                        $(".loading-container .loading-container__text--error").show();
                        $(".loading-container img").attr("src", "images/urofaint.gif");
                    });
                });
            </script>
        </div>
        <div id="helpModal" class="js--help-modal modal">
            <div class="js--help-modal__content modal__content">
                <div class="js--help-modal__content--localized modal__content--localized"></div>
                <a href="https://github.com/Flashfyre/Yume-2kki-Explorer/issues/new" target="_blank" data-localize="helpModal.reportBug">Report a Bug</a>
            </div>
        </div>
    </body>
</html>