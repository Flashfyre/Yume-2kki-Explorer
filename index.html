<html>
    <head>
        <title data-localize="title">Yume 2kki Explorer</title>
        <link rel="shortcut icon" href="/favicon.ico">
        <style>
            @font-face {
                font-family: 'MS Gothic';
                src: url('/fonts/MS Gothic.ttf');
            }

            body {
                font-family: 'MS Gothic';
                margin: 0;
                background: url(https://img2.wikia.nocookie.net/__cb20140715140243/yume2kki/images/5/50/Wiki-background) top left repeat;
                background-blend-mode: screen;
                overflow: hidden;
            }

            .noselect {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            .content {
                background: rgba(0,0,0,0.8);
                padding-top: 0.1px;
            }

            .controls--container {
                position: absolute;
                width: 100%;
                z-index: 10;
                pointer-events: none;
            }

            .controls {
                position: absolute;
                display: flex;
                flex-wrap: wrap;
                justify-content: flex-end;
                text-align: right;
                margin: 10px;
                margin-top: 10px;
                width: calc(100% - 40px);
                min-height: 64px;
                border: 10px solid transparent;
            }

            .controls-top {
                z-index: 10;
            }

            .controls-bottom {
                pointer-events: none;
            }

            .controls-bottom.visible {
                pointer-events: all !important;
            }

            .controls--container--tab {
                position: absolute;
                width: 128px;
                z-index: 5;
                top: calc(100% - 36px);
            }

            .controls--container--tab__button {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
                height: 16px;
                padding: 6px 0 24px 0;
                font-family: 'MS Gothic';
                font-size: 18px;
                border: none;
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;
                background-image: none;
                background-color: rgba(255, 255, 255, 0.25);
            }

            .control {
                display: flex;
                align-items: center;
                padding: 8px;
            }

            .loading-container {
                width: 100%;
                height: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }

            .loading-container .loading-container__text {
                font-size: xx-large;
                margin-left: 12px;
            }

            .loading-container img {
                -ms-interpolation-mode: nearest-neighbor;
                image-rendering: pixelated;
                height: 25%;
            }

            .graph {
                width: 100%;
                height: 100%;
            }

            .footer {
                position: absolute;
                padding: 8px;
                padding-left: 4px;
                top: calc(100% - 36px);
                text-align: right;
                height: 26px;
                width: calc(100% - 16px);
                font-family: 'MS Gothic';
                font-size: 18px;
            }

            label {
                font-size: 18px;
                margin-left: 16px;
                font-weight: bold;
            }

            button {
                margin: 8px;
                padding: 4px;
                cursor: pointer;
                font-family: 'MS Gothic';
                font-size: 18px;
                border: 6px solid transparent;
            }

            input[type='text'], select, .slider {
                margin: 8px;
                padding: 4px;
                font-family: 'MS Gothic';
                font-size: 18px;
                border: 6px solid transparent;
            }

            .slider {
                -webkit-appearance: none;
                appearance: none;
                width: 128px;
                height: 2px;
                padding: 0 4px;
                outline: none;
            }

            .slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 24px;
                height: 38px;
                border: 6px solid transparent;
                cursor: pointer;
            }

            .slider::-moz-range-thumb {
                width: 25px;
                height: 25px;
                width: 24px;
                height: 38px;
                border: 6px solid transparent;
                cursor: pointer;
            }

            .autocomplete-suggestions {
                border: 6px solid transparent;
                overflow: auto;
            }

            .autocomplete-suggestion {
                padding: 2px 5px;
                white-space: nowrap;
                overflow: hidden;
            }

            .autocomplete-suggestions strong {
                font-weight: normal;
            }

            .autocomplete-group {
                padding: 2px 5px;
            }

            .autocomplete-group strong {
                display: block;
                border-bottom: 1px solid #000;
            }

            .context-menu-list {
                border: 0 !important;
                padding: 0 !important;
            }

            .context-menu-item {
                border: 6px solid transparent;
            }
        </style>
        <style class="js--theme-styles">
            body {
                background-color: #000000; /*base*/
            }

            .controls {
                background: url(/images/ui/Default_Custom/containerbg.png);
                border-image: url(/images/ui/Default_Custom/border.png);
                border-image-slice: 12;
                border-image-repeat: repeat;
            }

            .controls--container--tab__button {
                color: rgba(216, 216, 216, 1); /*base*/
            }

            label, .loading-container .loading-container__text {
                background-image: url(/images/ui/Default_Custom/font1.png);
                -webkit-background-clip: text;
	            -webkit-text-fill-color: transparent;
                background-clip: text;
                background-size: 18px;
            }

            .footer {
                color: rgba(216, 216, 216, 1); /*base*/
            }

            button {
                color: rgba(216, 216, 216, 1); /*base*/
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-image: url(/images/ui/Default_Custom/containerbg.png);
            }

            input[type='text'], select, .slider {
                color: rgba(216, 216, 216, 1); /*base*/
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-color: rgba(45, 17, 23, 1); /*base*/
            }

            input[type='text'].selected {
                color: rgba(255, 255, 157, 1); /*alt*/
            }

            .slider::-webkit-slider-thumb {
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-color: rgba(45, 17, 23, 1); /*base*/
            }

            .slider::-moz-range-thumb {
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-color: rgba(45, 17, 23, 1); /*base*/
            }

            .autocomplete-suggestions {
                color: rgba(216, 216, 216, 1); /*base*/
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-color: rgba(45, 17, 23, 1); /*base*/
            }

            .autocomplete-selected {
                background-color: rgba(93, 65, 71, 1); /*alt*/
            }
            
            .autocomplete-suggestions strong {
                color: rgba(255, 255, 157, 1); /*alt*/
            }

            .context-menu-item {
                color: rgba(216, 216, 216, 1) !important; /*base*/
                border-image: url(/images/ui/Default_Custom/border.png) 8 round !important;
                background-color: rgba(45, 17, 23, 1) !important; /*base*/
                background-image: url(/images/ui/Default_Custom/containerbg.png) !important;
            }

            .context-menu-item.context-menu-hover {
                color: rgba(255, 255, 157, 1) !important; /*alt*/
            }
        </style>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery-contextmenu/2.9.0/jquery.contextMenu.min.css" />
        <script src="/js/3d-force-graph-modded.js"></script>
        <script src="//unpkg.com/d3-quadtree"></script>
        <script src="//unpkg.com/d3-force"></script>
        <script src="//unpkg.com/three"></script>
        <script src="//unpkg.com/three-spritetext"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.devbridge-autocomplete/1.4.10/jquery.autocomplete.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-localize/0.1.0/jquery.localize.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-contextmenu/2.9.0/jquery.contextMenu.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-contextmenu/2.9.0/jquery.ui.position.min.js"></script>
        <script src="/js/conn-type.js"></script>
    </head>
    <body>
        <div class="content">
            <div class="controls controls-top">
                <div class="control">
                    <label data-localize="search.name" class="noselect">Search:</label>
                    <input name="searchWorld" type="text" class="js--world-input js--search-world" />
                </div>
                <div class="control">
                    <label data-localize="origin.name" class="noselect">Origin:</label>
                    <input name="startWorld" type="text" class="js--world-input js--path--world-input js--start-world" />
                    <label data-localize="destination.name" class="noselect">Destination:</label>
                    <input name="endWorld" type="text" class="js--world-input js--path--world-input js--end-world" />
                    <button data-localize="reset" class="js--reset noselect">Reset</button>
                </div>
            </div>
            <div id="graph" class="graph">
                <div class="loading-container">
                    <span class="loading-container__text loading-container__text--loading"><span data-localize="loading.label" class="loading-container__text__main">Loading</span><span data-localize="loading.space" class="loading-container__text__append">   </span></span>
                    <span class="loading-container__text loading-container__text--error" data-localize="loading.error" style="display: none;"></span>
                    <img src="images/urowalk.gif" />
                </div>
            </div>
            <div class="controls--container--tab">
                <button class="controls--container--tab__button noselect">▲</button>
            </div>
            <div class="controls--container controls-bottom--container">
                <div class="controls controls-bottom" style="opacity: 0;">
                    <div class="control">
                        <label data-localize="lang.name" class="noselect">Language:</label>
                        <select name="language" class="js--lang">
                            <option data-localize="lang.values.english" value="en" selected>English</option>
                            <option data-localize="lang.values.japanese" value="ja">Japanese</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="uiTheme.name" class="noselect">UI Theme:</label>
                        <select name="uiTheme" class="js--ui-theme">
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="fontStyle.name" class="noselect">Font Style:</label>
                        <select name="fontStyle" class="js--font-style">
                            <option data-localize="fontStyle.values.style1" value="0">Style 1</option>
                            <option data-localize="fontStyle.values.style2" value="1">Style 2</option>
                            <option data-localize="fontStyle.values.style3" value="2">Style 3</option>
                            <option data-localize="fontStyle.values.style4" value="3">Style 4</option>
                            <option data-localize="fontStyle.values.style5" value="4">Style 5</option>
                            <option data-localize="fontStyle.values.style6" value="5">Style 6</option>
                            <option data-localize="fontStyle.values.style7" value="6">Style 7</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="displayMode.name" class="noselect">Display Mode:</label>
                        <select name="displayMode" class="js--display-mode">
                            <option data-localize="displayMode.values.vertical" value="0" selected>Vertical</option>
                            <option data-localize="displayMode.values.horizontal" value="1">Horizontal</option>
                            <option data-localize="displayMode.values.radialIn" value="2">Inward</option>
                            <option data-localize="displayMode.values.radialOut" value="3">Outward</option>
                            <option data-localize="displayMode.values.free" value="4">Free</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="connMode.name" class="noselect">Connection Mode:</label>
                        <select name="connMode" class="js--conn-mode">
                            <option data-localize="connMode.values.oneWay" value="0" selected>One-Way)/option>
                            <option data-localize="connMode.values.twoWay" value="1">Two-Way</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="labelMode.name" class="noselect">Label Display:</label>
                        <select name="labelMode" class="js--label-mode">
                            <option data-localize="labelMode.values.never" value="0">Never</option>
                            <option data-localize="labelMode.values.hover" value="1" selected>On Hover</option>
                            <option data-localize="labelMode.values.select" value="2">On Select</option>
                            <option data-localize="labelMode.values.always" value="3">Always</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="sizeDiff.name" class="noselect">Size Difference:</label>
                        <input type="range" min="1" max="10" value="1" step="0.5" class="js--size-diff slider" />
                    </div>
                    <div class="control js--stack-size--container">
                        <label data-localize="stackSize.name" class="noselect">Stack Threshold:</label>
                        <input type="range" min="5" max="100" value="20" step="1" class="js--stack-size slider" />
                    </div>
                </div>
            </div>
            <div data-localize="footer" class="footer noselect"></div>
            <script>
                $(document).keydown(function (event) {
                    if (event.which === 16)
                        isShift = true;
                    else if (event.which === 17)
                        isCtrl = true;
                });

                $(document).keyup(function (event) {
                    if (event.which === 16)
                        isShift = false;
                    else if (event.which === 17)
                        isCtrl = false;
                });

                let isShift = false;
                let isCtrl = false;

                $.fn.extend({
                    animateCss: function (animation, duration, endCallback) {
                        const animationEnd = "webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend";
                        $(this).removeClass($(this).data("animateCss")).trigger("webkitAnimationEnd");
                        if (!duration)
                            duration = 250;
                        $(this).css({
                            "-webkit-animation-duration": duration + "ms",
                            "animation-duration": duration + "ms"
                        });
                        const classes = "animated " + animation;
                        $(this).data("animateCss", classes);

                        $(this).addClass(classes).one(animationEnd, function () {
                            $(this).off(animationEnd);
                            $(this).css({
                                "-webkit-animation-duration": "initial",
                                "animation-duration": "initial"
                            });
                            if (endCallback)
                                endCallback.apply(this);
                            $(this).removeClass(classes);
                        });

                        return this;
                    }
                });

                CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
                    if (width < 2 * radius) radius = width / 2;
                    if (height < 2 * radius) radius = height / 2;
                    this.moveTo(x + radius, y);
                    this.arcTo(x + width, y, x + width, y + height, radius);
                    this.arcTo(x + width, y + height, x, y + height, radius);
                    this.arcTo(x, y + height, x, y, radius);
                    this.arcTo(x, y, x + width, y, radius);
                    return this;
                };

                CanvasRenderingContext2D.prototype.emoji = function (x, y, scale, emoji) {
                    this.beginPath();
                    
                    switch (emoji) {
                        case "⛔":
                        case "🚫":
                            this.arc(x + 3.125 * scale, y - 2.1 * scale, 3.3 * scale, 0, 2 * Math.PI);
                            break;
                        case "🔒":
                        case "🔐":
                            const isCondition = emoji === "🔐";
                            this.roundRect(x - 0.21 * scale, y - 2.45 * scale, 5.4 * scale, 3.7 * scale, 0.5 * scale);
                            if (isCondition)
                                this.arc(x + 4.875 * scale, y - 3 * scale, 1.6 * scale, 0, 2 * Math.PI);
                            this.moveTo(x + 0.175 * scale, y - 2.445 * scale);
                            this.arc(x + 2.5 * scale, y - 3.1 * scale, 2.325 * scale, Math.PI, 0);
                            this.lineTo(x + 4.825 * scale, y - 2.445 * scale);
                            if (isCondition) {
                                this.moveTo(x + 5.65 * scale, y - 1.5825 * scale);
                                this.lineTo(x + 5.65 * scale, y + 0.525 * scale);
                                this.lineTo(x + 4.85 * scale, y + 1.2375 * scale);
                                this.lineTo(x + 4.85 * scale, y - 1.5825 * scale);
                            }
                            break;
                        case "🔑":
                            this.moveTo(x + 3.75 * scale, y - 2.9 * scale);
                            this.lineTo(x + 6.5 * scale, y - 0.15 * scale);
                            this.lineTo(x + 6.5 * scale, y + 1.2 * scale);
                            this.lineTo(x + 4.85 * scale, y + 1.2 * scale);
                            this.lineTo(x + 4.85 * scale, y + 0.6 * scale);
                            this.lineTo(x + 4.15 * scale, y + 0.6 * scale);
                            this.lineTo(x + 4.15 * scale, y);
                            this.lineTo(x + 3.5 * scale, y);
                            this.lineTo(x + 3.5 * scale, y - 0.6 * scale);
                            this.lineTo(x + 3.1 * scale, y - 0.6 * scale);
                            this.lineTo(x + 2.4 * scale, y - 1.4 * scale);
                            this.arc(x + 1.85 * scale, y - 3.35 * scale, 2.1 * scale, 0.4 * Math.PI, 2.4 * Math.PI)
                            break;
                        case "🚩":
                            this.moveTo(x - 0.05 * scale, y + 1.25 * scale);
                            this.lineTo(x - 0.05 * scale, y - 4.25 * scale);
                            this.arc(x + 0.475 * scale, y - 4.75 * scale, 0.725 * scale, 0.75 * Math.PI, 2.05 * Math.PI);
                            this.lineTo(x + 5.9 * scale, y - 3.1 * scale);
                            this.arc(x + 5.675 * scale, y - 2.775 * scale, 0.375 * scale, 1.5 * Math.PI, 0.4 * Math.PI);
                            this.lineTo(x + 1 * scale, y - 0.8 * scale);
                            this.lineTo(x + 1 * scale, y + 1.25 * scale);
                            break;
                        case "↩️":
                            this.rect(x - 0.2 * scale, y - 5.425 * scale, 6.675 * scale, 6.675 * scale);
                            break;
                        case "✨":
                            this.moveTo(x + 1.5 * scale, y - 2.64 * scale);
                            this.bezierCurveTo(x + 3.6 * scale, y - 2.15 * scale, x + 3.35 * scale, y - 4.7 * scale, x + 3.35 * scale, y - 4.7 * scale);
                            this.arc(x + 3.85 * scale, y - 4.8 * scale, 0.5 * scale, Math.PI, 2 * Math.PI);
                            this.bezierCurveTo(x + 4.05 * scale, y - 2.25 * scale, x + 6 * scale, y - 2.5 * scale, x + 6 * scale, y - 2.5 * scale);
                            this.arc(x + 6 * scale, y - 2 * scale, 0.5 * scale, 1.5 * Math.PI, 0.5 * Math.PI);
                            this.bezierCurveTo(x + 4.05 * scale, y - 1.75 * scale, x + 4.35 * scale, y + 0.7 * scale, x + 4.35 * scale, y + 0.7 * scale);
                            this.arc(x + 3.85 * scale, y + 0.8 * scale, 0.5 * scale, 0, Math.PI);
                            this.bezierCurveTo(x + 3.6 * scale, y - 1.75 * scale, x + 1.5 * scale, y - 1.5 * scale, x + 1.5 * scale, y - 1.5 * scale);
                            this.roundRect(x - 0.2 * scale, y - 3.35 * scale, 2.65 * scale, scale, 0.5 * scale);
                            this.roundRect(x + 0.6 * scale, y - 4.4 * scale, 1.05 * scale, 3.1 * scale, 0.5 * scale);
                            this.rect(x + 2.6 * scale, y - 1.2 * scale, 0.4 * scale, 0.4 * scale);
                            this.roundRect(x + 0.85 * scale, y - 0.85 * scale, 2.65 * scale, scale, 0.5 * scale);
                            this.roundRect(x + 1.65 * scale, y - 1.9 * scale, 1.05 * scale, 3.1 * scale, 0.5 * scale);
                            break;
                        case "🍀":
                            this.arc(x + 1 * scale, y - 3.325 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 2.125 * scale, y - 4.4 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 4.1 * scale, y - 4.4 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 5.225 * scale, y - 3.325 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 0.875 * scale, y - 1.375 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 1.975 * scale, y - 0.275 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 3.125 * scale, y + 0.7 * scale, 0.575 * scale, 0, 2 * Math.PI);
                            this.arc(x + 5.375 * scale, y - 1.375 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 4.225 * scale, y - 0.275 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.lineTo(x + 3.5 * scale, y + 0.85 * scale);
                            this.lineTo(x + 2 * scale, y + 0.85 * scale);
                            this.rect(x + 1.5 * scale, y - 3.5 * scale, 3.25 * scale, 4 * scale);
                            break;
                    }
                    this.closePath();
                };

                function hueToRGBA(h, a) {
                    let s = 1, v = 1, r, g, b, i, f, p, q, t;
                    i = Math.floor(h * 6);
                    f = h * 6 - i;
                    p = v * (1 - s);
                    q = v * (1 - f * s);
                    t = v * (1 - (1 - f) * s);
                    switch (i % 6) {
                        case 0: r = v, g = t, b = p; break;
                        case 1: r = q, g = v, b = p; break;
                        case 2: r = p, g = v, b = t; break;
                        case 3: r = p, g = q, b = v; break;
                        case 4: r = t, g = p, b = v; break;
                        case 5: r = v, g = p, b = q; break;
                    }
                    return "rgba(" + Math.round(r * 255) + "," + Math.round(g * 255) + "," + Math.round(b * 255) + "," + a + ")";
                }

                function getFontColor(fontStyle, callback) {
                    const uiTheme = config.uiTheme;
                    if (!uiThemeFontColors[uiTheme])
                        uiThemeFontColors[uiTheme] = {};
                    let pixel = uiThemeFontColors[uiTheme][fontStyle];
                    if (pixel)
                        return callback("rgba(" + pixel[0] + ", " + pixel[1] + ", " + pixel[2] + ", 1)");
                    const img = new Image();
                    img.onload = function () {
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        context.drawImage(img, 0, 0);
                        pixel = context.getImageData(0, 8, 1, 1).data;
                        uiThemeFontColors[uiTheme][fontStyle] = [ pixel[0], pixel[1], pixel[2] ];
                        callback("rgba(" + pixel[0] + ", " + pixel[1] + ", " + pixel[2] + ", 1)");
                        canvas.remove();
                    };
                    img.src = "./images/ui/" + config.uiTheme + "/font" + (fontStyle + 1) + ".png";
                }

                function getBaseBgColor(uiTheme, callback) {
                    const img = new Image();
                    let pixel = uiThemeBgColors[uiTheme];
                    if (pixel)
                        return callback("rgba(" + pixel[0] + ", " + pixel[1] + ", " + pixel[2] + ", 1)");
                    img.onload = function () {
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        context.drawImage(img, 0, 0);
                        pixel = context.getImageData(0, 0, 1, 1).data;
                        const pixel2 = context.getImageData(4, 4, 1, 1).data;
                        const pixel3 = context.getImageData(8, 8, 1, 1).data;
                        const r = Math.round((pixel[0] + pixel2[0] + pixel3[0]) / 3);
                        const g = Math.round((pixel[1] + pixel2[1] + pixel3[1]) / 3);
                        const b = Math.round((pixel[2] + pixel2[2] + pixel3[2]) / 3);
                        uiThemeBgColors[uiTheme] = [ r, g, b ];
                        callback("rgba(" + r + ", " + g + ", " + b + ", 1)");
                        canvas.remove();
                    };
                    img.src = "./images/ui/" + uiTheme + "/containerbg.png";
                }

                let worldData;

                function loadOrInitConfig() {
                    try {
                        if (!window.localStorage.hasOwnProperty("config")) {
                            window.localStorage.setItem("config", JSON.stringify(config));
                        } else {
                            const savedConfig = JSON.parse(window.localStorage.getItem("config"));
                            const configKeys = Object.keys(savedConfig);
                            for (let c in configKeys) {
                                const key = configKeys[c];
                                if (config.hasOwnProperty(key)) {
                                    const value = savedConfig[key];
                                    config[key] = value;
                                    switch (key) {
                                        case "lang":
                                            $(".js--lang").val(value);
                                            break;
                                        case "uiTheme":
                                            $(".js--ui-theme").val(value);
                                            break;
                                        case "fontStyle":
                                            $(".js--font-style").val(value);
                                            break;
                                        case "displayMode":
                                            $(".js--display-mode").val(value);
                                            if (parseInt(value) >= 2)
                                                $(".js--stack-size--container").css("display", "none");
                                            break;
                                        case "connMode":
                                            $(".js--conn-mode").val(value);
                                            break;
                                        case "labelMode":
                                            $(".js--label-mode").val(value);
                                            break;
                                        case "sizeDiff":
                                            $(".js--size-diff").val(value);
                                            break;
                                        case "stackSize":
                                            $(".js--stack-size").val(value);
                                            break;
                                    }
                                }
                            }
                        }
                    } catch (error) {
                    }
                }

                function updateConfig() {
                    try {
                        window.localStorage.config = JSON.stringify(config);
                    } catch (error) {
                    }
                }

                function updateControlsContainer(updateTabMargin) {
                    const controlsHeight = $(".controls-bottom").outerHeight();
                    $(".controls--container").css({ "height": controlsHeight + "px", "margin-top": "-" + (controlsHeight + 20) + "px" });
                    $(".controls--container--tab").css({ "height": controlsHeight + "px", "left": "calc(50% - " + (($(".controls--container--tab").outerWidth() - 16) / 2) + "px)" });
                    if (updateTabMargin && $(".controls-bottom").hasClass("visible"))
                        $(".controls--container--tab, .footer").css("margin-top", "-" + (controlsHeight + 8) + "px");
                }

                function loadWorldData(update, success, fail) {
                    $.get("/worlds" + (update ? "?update=true" : ""), success).fail(fail);
                }

                let graph;
                
                let contextWorldId = null, startWorldId = null, endWorldId = null, selectedWorldId = null;

                let searchWorldIds = [], visibleWorldIds = [];

                let icons3D = [];

                let localizedConns;
                
                let effectsJP;

                let uiThemeBgColors = {};

                let uiThemeFontColors = {};

                let config = {
                    lang: "en",
                    uiTheme: "Default_Custom",
                    fontStyle: 0,
                    displayMode: 0,
                    connMode: 0,
                    labelMode: 1,
                    sizeDiff: 1,
                    stackSize: 20
                };

                function initGraph(displayMode, paths) {

                    const links = [];

                    const oneWayLinks = [];

                    let lastOneWayLinkKey;

                    let dashOffset = 0;

                    const addedLinks = [];

                    const worldScales = {};

                    const dagIgnore = {};

                    _.each(worldData, w => {
                        worldScales[w.id] = 1 + (Math.round((w.size - minSize) / (maxSize - minSize) * 10 * (config.sizeDiff - 1)) / 10);
                    });

                    if (paths) {
                        visibleWorldIds = _.uniq(_.flatten(paths).map(p => p.id));
                        const pathScores = [];
                        let minPathDepth = paths[0].length - 2;
                        let maxPathDepth;
                        let depthDiff;
                        let maxPathScore;
                        for (let pi in paths) {
                            const path = paths[pi];
                            if (path.length - 2 > minPathDepth * 2) {
                                let visibleWorldIdRemovalCandidates = _.uniq(_.flatten(paths.slice(pi)).map(p => p.id));
                                paths = paths.slice(0, pi);
                                let requiredWorldIds = _.uniq(_.flatten(paths).map(p => p.id));
                                _.remove(visibleWorldIdRemovalCandidates, w => requiredWorldIds.indexOf(w) > -1);
                                _.remove(visibleWorldIds, w => visibleWorldIdRemovalCandidates.indexOf(w) > -1);
                                break;
                            }
                            pathScores[pi] = parseInt(pi) + 3 * ((path.length - 2) - minPathDepth);
                        }
                        maxPathDepth = paths[paths.length - 1].length;
                        depthDiff = maxPathDepth - minPathDepth;
                        maxPathScore = ((paths.length - 1) + (3 * depthDiff)) * (depthDiff > 0 ? 1 : 2) || 1;
                        if (paths.length === 1 && paths[0][0].connType & ConnType.INACCESSIBLE)
                            pathScores[0] = maxPathScore;
                        for (let p in paths) {
                            const path = paths[p];
                            for (let w = 1; w < path.length; w++) {
                                const sourceId = path[w - 1].id;
                                const targetId = path[w].id;
                                const linkId = `${sourceId}_${targetId}`;
                                const hue = 0.6666 - ((pathScores[p] / maxPathScore) * 0.6666);
                                if (addedLinks.indexOf(linkId) === -1) {
                                    dagIgnore[sourceId] = [];
                                    const link = {
                                        key: linkId,
                                        source: sourceId,
                                        target: targetId,
                                        sourceScale: worldScales[sourceId],
                                        targetScale: worldScales[targetId],
                                        connType: path[w - 1].connType,
                                        typeParams: path[w - 1].typeParams,
                                        icons: [],
                                        hidden: false,
                                        defaultColor: hueToRGBA(hue, 1),
                                        defaultColorFade: hueToRGBA(hue, 0.1),
                                        connTypeCheck: path[w - 1].connType ? 'replace' : undefined
                                    };
                                    links.push(link);
                                    addedLinks.push(linkId);
                                    if (path[w - 1].connType & ConnType.ONE_WAY)
                                        oneWayLinks.push(link);
                                }
                            }
                        }
                    } else {
                        visibleWorldIds = Object.keys(worldData).map(id => parseInt(id));

                        const maxDepth =  _.max(worldData.map(w => w.depth));

                        for (let w in visibleWorldIds) {
                            const world = worldData[visibleWorldIds[w]];
                            const connections = world.connections;
                            const dagIgnoreIds = dagIgnore[world.id] = [];
                            for (let c in connections) {
                                const conn = connections[c];
                                const connWorld = worldData[conn.targetId];
                                let hidden = false;
                                if (conn.type & ConnType.NO_ENTRY)
                                    hidden = true;
                                else if (world.depth >= connWorld.depth) {
                                    const sameDepth = world.depth === connWorld.depth;
                                    const reverseConn = connWorld.connections.filter(c => c.targetId === world.id);
                                    hidden = (!sameDepth && !reverseConn.length) || (reverseConn.length && !(reverseConn[0].type & ConnType.NO_ENTRY) && (!sameDepth || (!(conn.type & ConnType.ONE_WAY) && world.id > connWorld.id)));
                                    if (!hidden)
                                        dagIgnoreIds.push(connWorld.id);
                                }
                                if (hidden)
                                    dagIgnoreIds.push(connWorld.id);
                                const hue = 0.6666 - ((world.depth / (maxDepth - 1)) * 0.6666);
                                const link = {
                                    key: `${world.id}_${connWorld.id}`,
                                    source: world.id,
                                    target: connWorld.id,
                                    sourceScale: worldScales[world.id],
                                    targetScale: worldScales[connWorld.id],
                                    connType: conn.type,
                                    typeParams: conn.typeParams,
                                    icons: [],
                                    hidden: hidden,
                                    defaultColor: hueToRGBA(hue, 1),
                                    defaultColorFade: hueToRGBA(hue, 0.1),
                                    connTypeCheck: conn.type ? hidden ? 'after' : 'replace' : undefined
                                };
                                links.push(link);
                                if (!hidden && conn.type & ConnType.ONE_WAY)
                                    oneWayLinks.push(link);
                            }
                        }
                    }

                    initWorldSearch();

                    oneWayLinks.length && (lastOneWayLinkKey = oneWayLinks[oneWayLinks.length - 1].key);

                    links.forEach(l => {
                        const icons = l.icons;
                        const connType = l.connType;
                        if (connType & ConnType.INACCESSIBLE)
                            icons.push(getConnTypeIcon(ConnType.INACCESSIBLE));
                        else {
                            if (connType & ConnType.ONE_WAY)
                                icons.push(getConnTypeIcon(ConnType.ONE_WAY));
                            else if (connType & ConnType.NO_ENTRY)
                                icons.push(getConnTypeIcon(ConnType.NO_ENTRY));
                            if (connType & ConnType.UNLOCK)
                                icons.push(getConnTypeIcon(ConnType.UNLOCK));
                            else if (connType & ConnType.LOCKED)
                                icons.push(getConnTypeIcon(ConnType.LOCKED));
                            else if (connType & ConnType.LOCKED_CONDITION)
                                icons.push(getConnTypeIcon(ConnType.LOCKED_CONDITION, l.typeParams[ConnType.LOCKED_CONDITION]));
                            if (connType & ConnType.DEAD_END)
                                icons.push(getConnTypeIcon(ConnType.DEAD_END));
                            else if (connType & ConnType.ISOLATED)
                                icons.push(getConnTypeIcon(ConnType.ISOLATED));
                            if (connType & ConnType.EFFECT)
                                icons.push(getConnTypeIcon(ConnType.EFFECT, l.typeParams[ConnType.EFFECT]));
                            if (connType & ConnType.CHANCE)
                                icons.push(getConnTypeIcon(ConnType.CHANCE, l.typeParams[ConnType.CHANCE]));
                        }
                    });

                    const images = (paths ? worldData.filter(w => visibleWorldIds.indexOf(w.id) > -1) : worldData)
                        .map(d => {
                            const img = new Image();
                            img.id = d.id;
                            img.title = config.lang === "en" || !d.titleJP ? d.title : d.titleJP;
                            img.src = d.filename;
                            return img;
                        });

                    const nodes = images.map(img => {
                        const id = parseInt(img.id);
                        const scale = worldScales[id];
                        const ret = { id: id, img, isHover: false, scale: scale };
                        ret.globalDepth = worldData[id].depth;
                        ret.dagIgnore = dagIgnore[id];
                        ret.width = 16 * scale;
                        ret.height = 12 * scale;
                        return ret;
                    });

                    const radius = 12;
                
                    const gData = {
                        nodes: nodes,
                        links: links
                    };

                    let nodeDepths;

                    let depthDistances;

                    const elem = document.getElementById('graph');
                
                    graph = ForceGraph3D()(elem);
                                        
                    const maxAnisotropy = graph.renderer().capabilities.getMaxAnisotropy();
                    
                    if (displayMode < 4) {
                        graph = graph
                            .dagMode(displayMode === 0 ? 'td' : displayMode === 1 ? 'lr' : displayMode === 2 ? 'radialin' : 'radialout')
                            .dagLevelDistance(displayMode < 2 ? 12 : 24 + radius * (config.sizeDiff + 1));
                    }
                    graph
//                             if (isHover && (isShift || isCtrl)) {
//                                 ctx.fillText("🔗", x + (width / 2) - 3.5, y - (height / 2) + 2.5);
//                             }
                        .connMode(() => config.connMode)
                        .nodeVal(node => node.height)
                        .nodeLabel(node => node.img.title)
                        .nodesPerStack(config.stackSize)
                        .linkOpacity(1)
                        .linkWidth(link => selectedWorldId != null && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? 2 : 1)
                        .linkColor( link  =>  {
                            if(selectedWorldId != null && (selectedWorldId === link.source.id || link.target.id === selectedWorldId))
                                return 0xFFFFFF;
                            else if((selectedWorldId == null || selectedWorldId === link.source.id || selectedWorldId === link.target.id) && (!searchWorldIds.length || searchWorldIds.indexOf(link.source.id) > -1 || searchWorldIds.indexOf(link.target.id) > -1))
                                return link.defaultColor;
                            else
                                return link.defaultColorFade;
                        })
                        .linkVisibility(link => {
                            return 1;
//                             //don't duplicate links
//                             //works but removes particles in the process :<
//                             var result, result2;
//                             if(link.source.id == undefined || link.target.id == undefined) {
//                                 result = links.filter(lik => {return lik.key == link.source + '_' + link.target});
//                                 result2 = links.filter(lik => {return lik.key == link.target + '_' + link.source});
//                             } else {
//                                 result = links.filter(lik => {return lik.key == link.source.id + '_' + link.target.id});
//                                 result2 = links.filter(lik => {return lik.key == link.target.id + '_' + link.source.id});
//                             }

//                             if(result == undefined)
//                                return 0; // shouldn't happen

//                             if(result2[0] != undefined) {
//                                 if(result2[0].hidden != 0)
//                                    return 0;
//                                 else
//                                    return 1;
//                             } else
//                                 return 1;
                        })
//                         .linkCanvasObjectMode('connTypeCheck')
                        .linkDirectionalParticleWidth(3)
                        .linkDirectionalParticleColor(link => {
                            if(link.source.id == undefined || link.target.id == undefined) {
                                if((searchWorldIds.length && (searchWorldIds.indexOf(link.source) > -1 || searchWorldIds.indexOf(link.target) > -1) || !searchWorldIds.length && (selectedWorldId == null || link.source == selectedWorldId || link.target === selectedWorldId)))
                                    return 0xFFFFFF;
                                else
                                    return 0x333333;
                            } else {
                                if((searchWorldIds.length && (searchWorldIds.indexOf(link.source.id) > -1 || searchWorldIds.indexOf(link.target.id) > -1) || !searchWorldIds.length && (selectedWorldId == null || link.source.id === selectedWorldId || link.target.id === selectedWorldId)))
                                    return 0xFFFFFF;
                                else
                                    return 0x333333;
                            }
                        })
                        .linkDirectionalParticles(link =>  {
                            var result;
                            if(link.source.id == undefined || link.target.id == undefined)
                               result = links.filter(lik => {return lik.key == link.source + '_' + link.target});
                            else
                               result = links.filter(lik => {return lik.key == link.source.id + '_' + link.target.id});

                            if(result == undefined)
                               return 0; // shouldn't happen

                            var connType = result[0].connType;
                            if(connType && connType & ConnType.ONE_WAY)
                               return 3;
                            else
                               return 0;
                        })
                        .nodeThreeObject(node =>  {
                            var texture = new THREE.TextureLoader().load(worldData[node.id].filename);
                            texture.anisotropy = maxAnisotropy;
                            texture.minFilter = THREE.NearestFilter; // disables mipmaps (eliminates blur)
                            return new THREE.Mesh(new THREE.BoxGeometry(20, 20, 20), new THREE.MeshBasicMaterial({map: texture}));
//                              // test non-textured boxes
//                              return new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10),
//                                  new THREE.MeshBasicMaterial({color: 0x00aa22}))
                        })
                        .linkThreeObject(link => {
                            if(icons3D[link.key] == undefined) {
                                if(link.icons[0] != undefined) {
                                    //var myText = new SpriteText({text: link.icons[0].char, fontFace: 'MS Gothic'});
                                    var myText = new SpriteText(link.icons[0].char, 12, 0xFFFFFF);
                                    myText.fontFace = 'MS Gothic';
                                    myText.fontSize = 80;
                                    // without the border emojis get cropped - possibly a bug in three-spritetext
                                    myText.borderWidth = 1;
                                    myText.borderColor = 'transparent';
                                    icons3D[link.key] = myText;
                                    graph.scene().add(myText);
                                    if(config.connMode === 0 && (link.connType & ConnType.NO_ENTRY))
                                        icons3D[link.key].material.opacity = 0;
                                }
                            }
                            return 0;
                        })
                        .onNodeDragEnd(node => {
                            node.fx = node.x;
                            node.fy = node.y;
                            node.fz = node.z;
                        })
                        .onNodeHover((node, prevNode) => {
                            elem.style.cursor = node ? 'pointer' : null;
                            if (node)
                                node.isHover = true;
                            if (prevNode)
                                prevNode.isHover = false;
                        })
                        .onNodeClick(node => {
                            if (isCtrl || isShift)
                                openWorldWikiPage(node.id, isShift);
                            else {
                                const world = worldData[node.id];
                                if (node && (selectedWorldId == null || selectedWorldId !== node.id)) {
                                    $(".js--search-world").addClass("selected").val(config.lang === 'en' || !world.titleJP ? world.title : world.titleJP);
                                    selectedWorldId = node.id;
                                } else {
                                    focusNode(node);
                                    highlightWorldSelection();
                                }
                            }
                        })
                        .onNodeRightClick((node, ev) => {
                            contextWorldId = node.id;
                            $(".graph canvas").contextMenu({
                                x: ev.x,
                                y: ev.y
                            });
                        })
                        .onBackgroundClick(node => {
                            $(".js--search-world").removeClass("selected").val("");
                            if(selectedWorldId != null) {
                                selectedWorldId = null;
								highlightWorldSelection();
                            }
                        })
                        .iconLabel(icon => icon.text)
                        .cooldownTime(Infinity)
                        // Deactivate existing forces
                        // Add collision and bounding box forces
                        .d3Force('collide', d3.forceCollide((node) => radius * worldScales[node.id]))
                        .d3Force('box', () => {
                            const SQUARE_HALF_SIDE = radius * 50;

                            gData.nodes.forEach(node => {
                                const x = node.x || 0, y = node.y || 0, z = node.z || 0;

                                // bounce on box walls
                                if (Math.abs(x) > SQUARE_HALF_SIDE) { node.vx += 0.1 * (x > 0 ? -1 : 1); }
                                if (Math.abs(y) > SQUARE_HALF_SIDE) { node.vy += 0.1 * (y > 0 ? -1 : 1); }
                                if (Math.abs(z) > SQUARE_HALF_SIDE) { node.vz += 0.1 * (z > 0 ? -1 : 1); }
                            });
                        })
                        .linkPositionUpdate(function a(linkObject, { start, end }, link) {
                            if(icons3D[link.key] != undefined) {
                                var resX, resY, resZ;
                                var dist = new THREE.Vector3(start.x, start.y, start.z).distanceTo(new THREE.Vector3(end.x, end.y, end.z));
                                var rat = 20 / dist;
                                resX = (1 - rat) * start.x + rat * end.x;
                                resY = (1 - rat) * start.y + rat * end.y;
                                resZ = (1 - rat) * start.z + rat * end.z;
                                icons3D[link.key].position.set(resX, resY + 10, resZ);
                            }
                        })
                        .graphData(gData);
                }

                function getConnTypeIcon(connType, typeParams) {
                    const localizedConn = localizedConns[connType];
                    const char = getConnTypeChar(connType);
                    const name = localizedConn.name;
                    let description = localizedConn.description;
                    if (description) {
                        switch (connType) {
                            case ConnType.EFFECT:
                                description = typeParams && ((config.lang === 'en' && typeParams.params) || (config.lang !== 'en' && typeParams.paramsJP))
                                    ? description.replace('{0}', config.lang === 'en' ? typeParams.params : typeParams.paramsJP)
                                    : null;
                                break;
                            case ConnType.CHANCE:
                                description = typeParams && typeParams.params
                                    ? description.replace('{0}', config.lang === 'en' ? typeParams.params : typeParams.params.replace('%', '％'))
                                    : '';
                                break;
                            case ConnType.LOCKED_CONDITION:
                                description = typeParams && ((config.lang === 'en' && typeParams.params) || (config.lang !== 'en' && typeParams.paramsJP))
                                    ? description.replace('{0}', config.lang === 'en' ? typeParams.params : typeParams.paramsJP)
                                    : '';
                                break;
                        }
                    }
                    return {
                        char: char,
                        text: name + (description ? (config.lang === 'en' ? ' - ' : '：') + description : '')
                    };
                }

                function getConnTypeChar(connType) {
                    let char;
                    switch (connType) {
                        case ConnType.ONE_WAY:
                            char = "➡️";
                            break;
                        case ConnType.NO_ENTRY:
                            char = "⛔";
                            break;
                        case ConnType.UNLOCK:
                            char = "🔑";
                            break;
                        case ConnType.LOCKED:
                            char = "🔒";
                            break;
                        case ConnType.DEAD_END:
                            char = "🚩";
                            break;
                        case ConnType.ISOLATED:
                            char = "↩️";
                            break;
                        case ConnType.EFFECT:
                            char = "✨";
                            break;
                        case ConnType.CHANCE:
                            char = "🍀";
                            break;
                        case ConnType.LOCKED_CONDITION:
                            char = "🔐";
                            break;
                        case ConnType.INACCESSIBLE:
                            char = "🚫";
                            break;
                    }
                    return char;
                }

                function reloadGraph() {
                    const startWorld = startWorldId != null ? worldData[startWorldId] : null;
                    const endWorld = endWorldId != null ? worldData[endWorldId] : null;
                    const matchPaths = startWorld && endWorld && startWorld != endWorld
                        ? findPath(startWorld.id, endWorld.id, ConnType.NO_ENTRY | ConnType.DEAD_END | ConnType.ISOLATED)
                        : null;
                    if (graph)
                        graph._destructor();
                    initGraph(config.displayMode, matchPaths)
                }

                let mult = 1;

                function findPath(s, t, ignoreTypeFlags) {
                    const startTime = performance.now();

                    const checkedSourceNodes = [s];
                    const checkedTargetNodes = [t];

                    const source = worldData[s];
                    const target = worldData[t];

                    let matchPaths = [];

                    let sourcePaths = {};
                    let targetPaths = {};

                    let nextGenSourceWorlds = [source];
                    let nextGenTargetWorlds = [target];

                    let genIndex = 0;

                    sourcePaths[s] = [{ id: s, connType: null }];
                    targetPaths[t] = [{ id: t, connType: null }];
                  
                    while (genIndex <= 20) {
                        let sourceWorlds = nextGenSourceWorlds.slice(0);
                        let targetWorlds = nextGenTargetWorlds.slice(0);
                        nextGenSourceWorlds = [];
                        nextGenTargetWorlds = [];
                        for (let sw in sourceWorlds) {
                            const sourceWorld = sourceWorlds[sw];
                            const sourcePath = sourcePaths[sourceWorld.id];
                            //delete sourcePaths[sourceWorld.id];
                            const sourceConns = traverseConns(checkedSourceNodes, sourcePath, nextGenSourceWorlds, sourceWorld, ignoreTypeFlags, true);
                            $.extend(sourcePaths, sourceConns);
                        }
                        for (let tw in targetWorlds) {
                            const targetWorld = targetWorlds[tw];
                            const targetPath = targetPaths[targetWorld.id];
                            //delete targetPaths[targetWorld.id];
                            const targetConns = traverseConns(checkedTargetNodes, targetPath, nextGenTargetWorlds, targetWorld, ignoreTypeFlags, false);
                            $.extend(targetPaths, targetConns);
                        }
                        
                        genIndex++;

                        /*let checkedSourceIds = Object.keys(sourcePaths).map(id => parseInt(id));
                        let checkedTargetIds = Object.keys(targetPaths).map(id => parseInt(id));*/

                        $.grep(checkedSourceNodes, id => {
                            const ret = $.inArray(id, checkedTargetNodes) !== -1;
                            if (ret) {
                                let skip = false;

                                let sourcePath = _.cloneDeep(sourcePaths[id]);
                                let targetPath = _.cloneDeep(targetPaths[id]);

                                if (sourcePath[sourcePath.length - 1].id === id && targetPath[targetPath.length - 1].id === id) {
                                    sourcePath = sourcePath.slice(0, -1);
                                }

                                let loopWorldIds, sourcePathIds, targetPathIds;
                                while ((loopWorldIds = _.intersectionWith((sourcePathIds = sourcePath.map(sp => sp.id)), (targetPathIds = targetPath.map(tp => tp.id)), _.isEqual)).length) {
                                    //console.log("Loop found", worldData[loopWorldIds[0]].title, JSON.stringify(sourcePath.map(function(p) { return worldData[p].title})), JSON.stringify(targetPath.map(function(p) { return worldData[p].title})));
                                    sourcePath = sourcePath.slice(0, sourcePathIds.indexOf(loopWorldIds[0]));
                                    targetPath = targetPath.slice(0, targetPathIds.indexOf(loopWorldIds[0]) + 1);
                                    //console.log("Loop fixed", worldData[loopWorldIds[0]].title, JSON.stringify(sourcePath.map(function(p) { return worldData[p].title})), JSON.stringify(targetPath.map(function(p) { return worldData[p].title})));
                                }
                                
                                const matchPath = sourcePath.concat(targetPath.reverse());
                                for (let p in matchPaths) {
                                    for (let w = 1; w < matchPaths[p].length; w++) {
                                        const linkId = `${matchPaths[p][w - 1].id}_${matchPaths[p][w].id}`;
                                        for (let m = 1; m < matchPath.length; m++) {
                                            const matchLinkId = `${matchPath[m - 1].id}_${matchPath[m].id}`;
                                            if (linkId === matchLinkId) {
                                                skip = true;
                                                break;
                                            }
                                        }
                                        if (skip)
                                            break;
                                    }
                                    if (skip)
                                        break;
                                }
                                if (skip)
                                    return false;
                                _.remove(nextGenSourceWorlds, w => w.id === id);
                                _.remove(nextGenTargetWorlds, w => w.id === id);
                                matchPaths.push(matchPath);
                            }
                            return ret;
                        });
                    }

                    const endTime = performance.now();

                    console.log("Found", matchPaths.length, "matching path(s) in", Math.round((endTime - startTime) * 10) / 10, "ms");

                    if (!matchPaths.length) {
                        if (ignoreTypeFlags & ConnType.DEAD_END)
                            ignoreTypeFlags ^= (ConnType.DEAD_END | ConnType.ISOLATED);
                        else
                            ignoreTypeFlags = 0;
                        if (ignoreTypeFlags)
                            return findPath(s, t, ignoreTypeFlags);
                        else {
                            matchPaths = [ [ { id: s, connType: ConnType.INACCESSIBLE }, { id: t, connType: null } ] ];
                            return matchPaths;
                        }
                    } else {
                        if ((!(ignoreTypeFlags & ConnType.LOCKED) && _.every(matchPaths, mp => mp.filter(p => p.connType && p.connType & (ConnType.LOCKED | ConnType.LOCKED_CONDITION).length)))) {
                            const additionalPaths = findPath(s, t, (ignoreTypeFlags = ignoreTypeFlags | ConnType.LOCKED | ConnType.LOCKED_CONDITION));
                            if (additionalPaths.length && !(additionalPaths[0][0].connType & ConnType.INACCESSIBLE)) {
                                for (let ap in additionalPaths)
                                    matchPaths.push(additionalPaths[ap]);
                            }
                        }
                        matchPaths = _.sortBy(matchPaths, [ 'length' ]);
                        if (matchPaths.length > 5)
                            matchPaths = matchPaths.slice(0, 5);
                    }

                    return matchPaths;
                }

                function traverseConns(checkedNodes, path, nextGenWorlds, world, ignoreTypeFlags, isSource) {
                    const ret = {};
                    const conns = world.connections;
                    for (let c in conns) {
                        let connType = conns[c].type;
                        const typeParams = conns[c].typeParams;
                        if (isSource && connType & ignoreTypeFlags)
                            continue;
                        const connWorld = worldData[conns[c].targetId];
                        const id = connWorld.id;
                        if (checkedNodes.indexOf(id) === -1) {
                            // If checking from target
                            if (isSource) {
                                path[path.length - 1].connType = connType;
                                path[path.length - 1].typeParams = typeParams;
                                connType = null;
                            } else {
                                const reverseConn = connWorld.connections.filter(c => c.targetId === world.id);
                                let reverseConnType = 0;
                                if (reverseConn.length)
                                    reverseConnType = reverseConn[0].type;
                                else {
                                    if (connType & ConnType.ONE_WAY)
                                        reverseConnType |= ConnType.NO_ENTRY;
                                    else if (connType & ConnType.NO_ENTRY)
                                        reverseConnType |= ConnType.ONE_WAY;
                                    if (connType & ConnType.LOCKED)
                                        reverseConnType |= ConnType.UNLOCK;
                                    else if (connType & ConnType.UNLOCK)
                                        reverseConnType |= ConnType.LOCKED;
                                    if (connType & ConnType.DEAD_END)
                                        reverseConnType |= ConnType.ISOLATED;
                                    else if (connType & ConnType.ISOLATED)
                                        reverseConnType |= ConnType.DEAD_END;
                                }
                                connType = reverseConnType;
                                if (connType & ignoreTypeFlags)
                                    continue;
                            }
                            const connPath = path.slice(0);
                            connPath.push({
                                id: id,
                                connType: connType,
                                typeParams: typeParams
                            });
                            ret[id] = connPath;
                            checkedNodes.push(id);
                            nextGenWorlds.push(worldData[id]);
                        }
                    }
                    return ret;
                }

                function findConnectionAnomalies() {
                    const connData = {};
                    worldData.forEach(w => {
                        connData[w.id] = [];
                        worldData[w.id].connections.map(c => worldData[c.targetId]).forEach(c => {
                            connData[w.id].push(c.id);
                        });
                    }); 
                    Object.keys(connData).forEach(id => {
                        let connIds = connData[id].slice(0);
                        connIds.forEach(c => {
                            const index = connData[c].indexOf(parseInt(id));
                            if (index > -1) {
                                connData[id].splice(connData[id].indexOf(c), 1);
                                connData[c].splice(index, 1);
                            }
                        });
                    });
                    Object.keys(connData).forEach(id => {
                        if (connData[id].length) {
                            connData[id].forEach(c => {
                                console.log(worldData[c].title, "is missing a connection to", worldData[id].title);
                            });
                        }
                    });
                }

                function initLocalization(isInitial) {
                    const isEn = config.lang === "en";

                    $("[data-localize]").localize("ui", {
                        language: config.lang,
                        pathPrefix: "/lang",
                        callback: function (data, defaultCallback) {
                            data.footer = data.footer.replace("{VERSION}", "1.4.4");
                            localizedConns = data.conn;
                            initContextMenu(data.contextMenu);
                            if (isInitial) {
                                Object.keys(data.uiTheme.values).forEach(t => {
                                    $(".js--ui-theme").append('<option data-localize="uiTheme.values.' + t + '" value="' + t + '">' + data.uiTheme.values[t] + '</option>');
                                });
                                $(".js--ui-theme").val(config.uiTheme).change();
                            }
                            updateControlsContainer();
                            defaultCallback(data);
                        }
                    });

                    $.localize("conn", {
                        language: config.lang,
                        pathPrefix: "/lang",
                        callback: function (data) {
                            localizedConns = data;
                        }
                    });

                    if (isInitial) {
                        $.localize("effect", {
                            language: 'ja',
                            pathPrefix: "/lang",
                            callback: function (data) {
                                effectsJP = data;
                            }
                        });
                    }

                    $(".js--world-input").each(function() {
                        const val = $(this).val();
                        if (val && worldNames.indexOf(val) > -1) {
                            const world = worldsByName[worldNames[worldNames.indexOf(val)]];
                            $(this).val(isEn || !world.titleJP ? world.title : world.titleJP);
                        }
                    });

                    worldsByName = isEn ? _.keyBy(worldData, w => w.title) : _.keyBy(worldData, w => w.titleJP || w.title);

                    worldNames = Object.keys(worldsByName);

                    $(".js--path--world-input").each(function () {
                        $(this).off("change").autocomplete("destroy");
                        $(this).on("change", function () {
                            const currentWorldId = $(this).is(".js--start-world") ? startWorldId : endWorldId;
                            const currentWorld = worldData[currentWorldId];
                            if (currentWorld != null && $(this).val() !== (config.lang === 'en' || !currentWorld.titleJP ? currentWorld.title : currentWorld.titleJP)) {
                                let isReloadGraph;
                                $(this).removeClass("selected");
                                if ($(this).is(".js--start-world")) {
                                    isReloadGraph = endWorldId != null && endWorldId !== startWorldId;
                                    startWorldId = null;
                                } else {
                                    isReloadGraph = startWorldId != null && startWorldId !== endWorldId;
                                    endWorldId = null;
                                }
                                if (isReloadGraph)
                                    reloadGraph();
                            }
                        }).autocomplete({
                            lookup: worldNames,
                            triggerSelectOnValidInput: false,
                            onSelect: function (selectedWorld) {
                                let isReloadGraph;
                                const worldId = worldsByName[selectedWorld.value].id;
                                $(this).addClass("selected");
                                if ($(this).is(".js--start-world")) {
                                    startWorldId = worldId;
                                    isReloadGraph = endWorldId != null && endWorldId !== startWorldId;
                                } else {
                                    endWorldId = worldId;
                                    isReloadGraph = startWorldId != null && startWorldId !== endWorldId;
                                }
                                if (isReloadGraph)
                                    reloadGraph();
                            }
                        });
                    });
                }

                function initWorldSearch() {
                    const $search = $(".js--search-world");
                    $search.autocomplete("destroy");
                    const visibleWorldNames = worldData ? worldData.filter(w => visibleWorldIds.indexOf(w.id) > -1).map(w => config.lang === 'en' || !w.titleJP ? w.title : w.titleJP) : [];
                    if (selectedWorldId != null && visibleWorldIds.indexOf(selectedWorldId) === -1) {
                        $search.removeClass("selected").val("");
                        selectedWorldId = null;
                    }
                    $search.autocomplete({
                        lookup: visibleWorldNames,
                        triggerSelectOnValidInput: false,
                        onSearchComplete: function (query, searchWorlds) {
                            const selectedWorld = selectedWorldId != null ? worldData[selectedWorldId] : null;
                            const selectedWorldName = selectedWorld ? config.lang === 'en' || !selectedWorld.titleJP ? selectedWorld.title : selectedWorld.titleJP : null;
                            searchWorldIds = searchWorlds.length && (!selectedWorld || (searchWorlds.length > 1 || searchWorlds.filter(w => w.value !== selectedWorldName).length)) ? searchWorlds.map(w => worldsByName[w.value].id) : [];
                            if (searchWorldIds.length && selectedWorld && (searchWorldIds.length !== 1 || selectedWorldId !== searchWorldIds[0])) {
                                $search.removeClass("selected");
                                selectedWorldId = null;
                            }
                            highlightWorldSelection();
                        },
                        onSelect: function (selectedWorld) {
                            $search.addClass("selected");
                            selectedWorldId = worldsByName[selectedWorld.value].id;
                            focusNode(graph.graphData().nodes[selectedWorldId]);
                            highlightWorldSelection();
                        },
                        onHide: function () {
                           if (selectedWorldId != null) {
                                const selectedWorld = worldData[selectedWorldId];
                                const selectedWorldName = config.lang === 'en' || !selectedWorld.titleJP ? selectedWorld.title : wselectedWorld.titleJP;
                                if ($(this).val() !== selectedWorldName) {
                                    $search.removeClass("selected");
                                    selectedWorldId = null;
                                }
                            }
                            searchWorldIds = [];
                            highlightWorldSelection();
                        }
                    });
                }

                function initContextMenu(localizedContextMenu) {
                    $.contextMenu('destroy');
                    $.contextMenu({
                        selector: '.graph canvas', 
                        trigger: 'none',
                        items: {
                            "wiki": {
                                name: () => localizedContextMenu.items.wiki,
                                callback: () => openWorldWikiPage(contextWorldId)
                            },
                            "start": {
                                name: () => localizedContextMenu.items.start,
                                callback: function () {
                                    const world = worldData[contextWorldId];
                                    const worldName = config.lang === 'en' || !world.titleJP ? world.title : world.titleJP;
                                    $(".js--start-world").val(worldName).change().autocomplete().select(0);
                                }
                            },
                            "end": {
                                name: () => localizedContextMenu.items.end,
                                callback: function () {
                                    const world = worldData[contextWorldId];
                                    const worldName = config.lang === 'en' || !world.titleJP ? world.title : world.titleJP;
                                    $(".js--end-world").val(worldName).change().autocomplete().select(0);
                                }
                            }
                        }
                    });
                }

                function openWorldWikiPage(worldId, newWindow) {
                    const world = worldData[worldId];
                    window.open(config.lang === 'en' || !world.titleJP
                        ? 'https://yume2kki.fandom.com/wiki/' + world.title
                        : ('https://wikiwiki.jp/yume2kki-t/' + (world.titleJP.indexOf("：") > -1 ? world.titleJP.slice(0, world.titleJP.indexOf("：")) : world.titleJP)),
                        "_blank", newWindow ? "width=" + window.outerWidth + ",height=" + window.outerHeight : "");
                }

                function focusNode(node) {
                    const distance = 100;
                    const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
                    var cam = graph.cameraPosition();
                    graph.cameraPosition({ x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio}, node, 1000);
                }

                function updateConnectionModeIcons() {
                    graph.graphData().links.forEach(link => {
                        if(icons3D[link.key]) {
                            if(selectedWorldId != null && (selectedWorldId === link.source.id || link.target.id === selectedWorldId)) {
                                icons3D[link.key].material.opacity = 1.0;
                            } else if((selectedWorldId == null || selectedWorldId === link.source.id || selectedWorldId === link.target.id) && (!searchWorldIds.length || searchWorldIds.indexOf(link.source.id) > -1 || searchWorldIds.indexOf(link.target.id) > -1)) {
                                icons3D[link.key].material.opacity = 1.0;
                            } else {
                                icons3D[link.key].material.opacity = 0.2;
                           }

                           if(config.connMode === 0 && (link.connType & ConnType.NO_ENTRY))
                              icons3D[link.key].material.opacity = 0;
                        }
                    });
                }

                function highlightWorldSelection() {
                    graph.linkColor(graph.linkColor()).linkWidth(graph.linkWidth());
                    updateConnectionModeIcons();
                    graph.graphData().nodes.forEach(node => {
                        if((searchWorldIds.length && searchWorldIds.indexOf(node.id) > -1) || !searchWorldIds.length && (selectedWorldId == null || node.id && (node.id == selectedWorldId || worldData[selectedWorldId].connections.filter(c => c.targetId === node.id).length))) {
                            node.__threeObj.material.transparent = false;
                            node.__threeObj.material.opacity = 1.0;
                        } else {
                            node.__threeObj.material.transparent = true;
                            node.__threeObj.material.opacity = 0.2;
                       }
                    });
                }

                let worldsByName, worldNames, minSize, maxSize;

                $(document).ready(function () {
                    let loadingFrameCount = 0;
                    const loadingTimer = window.setInterval(function () {
                        let loadingTextAppend = "";
                        const loadingTextAppendChar = config.lang === "en" ? "." : "．";
                        const loadingTextSpaceChar = config.lang === "en" ? " " : "　";
                        for (var i = 0; i < 3; i++)
                            loadingTextAppend += i < loadingFrameCount ? loadingTextAppendChar : loadingTextSpaceChar;
                        $(".loading-container__text__append").text(loadingTextAppend);
                        loadingFrameCount += loadingFrameCount < 3 ? 1 : -3;
                    }, 300);
                    
                    $(".controls--container--tab__button").click(function() {
                        updateControlsContainer();
                        if ($(".controls-bottom").hasClass("visible")) {
                            $(".controls-bottom").removeClass("visible").animateCss("slideOutDown", 250, function () {
                                if (!$(this).hasClass("visible"))
                                    $(this).css("opacity", 0);
                            });
                            $(".controls--container--tab, .footer").css("margin-top", "0px").animateCss("slideInDown", 300);
                        } else {
                            $(".controls-bottom").addClass("visible").css("opacity", 1).animateCss("slideInUp", 250);
                            $(".controls--container--tab, .footer").css("margin-top", "-" + ($(".controls-bottom").outerHeight() + 8) + "px").animateCss("slideInUp", 250);
                        }
                    });

                    updateControlsContainer(true);
                    $(window).resize(updateControlsContainer).blur(function() {
                        isShift = false;
                        isCtrl = false;
                    });
                    
                    $(".js--lang").change(function() {
                        config.lang = $(this).val();
                        updateConfig();
                        initLocalization();
                        if (worldData)
                            reloadGraph();
                    });

                    $(".js--ui-theme").change(function() {
                        config.uiTheme = $(this).val();
                        const themeStyles = $(".js--theme-styles")[0];
                        getBaseBgColor(config.uiTheme || (config.uiTheme = "Default_Custom"), function (color) {
                            var bgColorPixel = uiThemeBgColors[config.uiTheme];
                            var altColor = "rgba(" + Math.min(bgColorPixel[0] + 48, 255) + ", " + Math.min(bgColorPixel[1] + 48, 255) + ", " + Math.min(bgColorPixel[2] + 48, 255) + ", 1)";
                            themeStyles.textContent = themeStyles.textContent.replace(/url\(\/images\/ui\/[a-zA-Z0-9\_]+\/(containerbg|border(?:2)?|font\d)\.png\)/g, "url(/images/ui/" + config.uiTheme + "/$1.png)")
                                .replace(/background-color:( *)[^;!]*(!important)?;( *)\/\*base\*\//g, "background-color:$1" + color + "$2;$3/*base*/")
                                .replace(/background-color:( *)[^;!]*(!important)?;( *)\/\*alt\*\//g, "background-color:$1" + altColor + "$2;$3/*alt*/");
                            $(".js--font-style").change();
                            updateConfig();
                        });
                    });

                    $(".js--font-style").change(function() {
                        config.fontStyle = parseInt($(this).val());
                        const themeStyles = $(".js--theme-styles")[0];
                        getFontColor(config.fontStyle, function (baseColor) {
                            getFontColor(config.fontStyle !== 4 ? 4 : 0, function (altColor) {
                                themeStyles.textContent = themeStyles.textContent = themeStyles.textContent.replace(/url\(\/images\/ui\/([a-zA-Z0-9\_]+)\/font\d\.png\)/g, "url(/images/ui/$1/font" + (config.fontStyle + 1) + ".png)")
                                    .replace(/([^\-])color:( *)[^;!]*(!important)?;( *)\/\*base\*\//g, "$1color:$2" + baseColor + "$3;$4/*base*/")
                                    .replace(/([^\-])color:( *)[^;!]*(!important)?;( *)\/\*alt\*\//g, "$1color:$2" + altColor + "$3;$4/*alt*/");
                                updateConfig();
                            });
                        });
                    });

                    $(".js--display-mode").change(function() {
                        config.displayMode = parseInt($(this).val());
                        updateConfig();
                        if (worldData)
                            reloadGraph();
                        $(".js--stack-size--container").css("display", config.displayMode < 2 ? "flex" : "none");
                    });

                    $(".js--conn-mode").change(function() {
                        config.connMode = parseInt($(this).val());
                        updateConnectionModeIcons();
                        updateConfig();
                    });

                    $(".js--label-mode").change(function() {
                        config.labelMode = parseInt($(this).val());
                        updateConfig();
                    });

                    $(".js--size-diff").change(function() {
                        config.sizeDiff = parseFloat($(this).val());
                        updateConfig();
                        if (worldData)
                            reloadGraph();
                    });

                    $(".js--stack-size").change(function() {
                        config.stackSize = parseInt($(this).val());
                        updateConfig();
                        if (worldData)
                            reloadGraph();
                    });

                    $(".js--reset").click(function() {
                        $(".js--world-input").removeClass("selected").val("");
                        startWorldId = null;
                        endWorldId = null;
                        selectedWorldId = null;
                        if (worldData)
                            reloadGraph();
                    });

                    loadOrInitConfig();

                    initLocalization(true);

                    loadWorldData(false, function (data) {
                        worldData = data;

                        for (let d in Object.keys(worldData)) {
                            const world = worldData[d];
                            world.id = parseInt(d);
                            world.connections.forEach(conn => {
                                const effectParams = conn.typeParams[ConnType.EFFECT];
                                if (effectParams) {
                                    effectParams.paramsJP = effectParams.params.split(',').map(e => effectsJP[e]).join('」か「');
                                    effectParams.params = effectParams.params.replace(/,/g, ', ');
                                }
                            });
                        }

                        initLocalization();

                        const worldSizes = worldData.map(w => w.size); 

                        minSize = _.min(worldSizes);
                        maxSize = _.max(worldSizes);

                        window.clearInterval(loadingTimer);

                        reloadGraph();
                    }, function () {
                        window.clearInterval(loadingTimer);
                        $(".loading-container .loading-container__text--loading").hide();
                        $(".loading-container .loading-container__text--error").show();
                        $(".loading-container img").attr("src", "images/urofaint.gif");
                    });
                });
            </script>
        </div>
    </body>
</html>