<html>
    <head>
        <link rel="shortcut icon" href="/favicon.ico">
        <style>
            @font-face {
                font-family: 'MS Gothic';
                src: url('/fonts/MS Gothic.ttf');
            }

            body {
                font-family: 'MS Gothic';
                margin: 0;
                background: url(https://img2.wikia.nocookie.net/__cb20140715140243/yume2kki/images/5/50/Wiki-background) top left repeat;
                background-blend-mode: screen;
                overflow: hidden;
            }

            .noselect {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            .content {
                background: rgba(0,0,0,0.8);
                padding-top: 0.1px;
            }

            .controls--container {
                position: absolute;
                width: 100%;
                z-index: 10;
                pointer-events: none;
            }

            .controls {
                position: absolute;
                display: flex;
                flex-wrap: wrap;
                justify-content: flex-end;
                text-align: right;
                margin: 10px;
                margin-top: 10px;
                width: calc(100% - 40px);
                min-height: 64px;
                border: 10px solid transparent;
            }

            .controls-top {
                z-index: 10;
            }

            .controls-bottom {
                pointer-events: none;
            }

            .controls-bottom.visible {
                pointer-events: all !important;
            }

            .controls--container--tab {
                position: absolute;
                width: 128px;
                z-index: 5;
                top: calc(100% - 36px);
            }

            .controls--container--tab__button {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
                height: 16px;
                padding: 6px 0 24px 0;
                font-family: 'MS Gothic';
                font-size: 18px;
                border: none;
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;
                background-image: none;
                background-color: rgba(255, 255, 255, 0.25);
            }

            .control {
                display: flex;
                align-items: center;
                padding: 8px;
            }

            .graph {
                width: 100%;
                height: 100%;
            }

            .footer {
                position: absolute;
                padding: 8px;
                padding-left: 4px;
                top: calc(100% - 36px);
                text-align: right;
                height: 26px;
                width: calc(100% - 16px);
                font-family: 'MS Gothic';
                font-size: 18px;
            }

            label {
                font-size: 18px;
                margin-left: 16px;
                font-weight: bold;
            }

            button {
                margin: 8px;
                padding: 4px;
                cursor: pointer;
                font-family: 'MS Gothic';
                font-size: 18px;
                border: 6px solid transparent;
            }

            input[type='text'], select, .slider {
                margin: 8px;
                padding: 4px;
                font-family: 'MS Gothic';
                font-size: 18px;
                border: 6px solid transparent;
            }

            .slider {
                -webkit-appearance: none;
                appearance: none;
                width: 128px;
                height: 2px;
                padding: 0 4px;
                outline: none;
            }

            .slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 24px;
                height: 38px;
                border: 6px solid transparent;
                cursor: pointer;
            }

            .slider::-moz-range-thumb {
                width: 25px;
                height: 25px;
                width: 24px;
                height: 38px;
                border: 6px solid transparent;
                cursor: pointer;
            }

            .autocomplete-suggestions {
                border: 6px solid transparent;
                overflow: auto;
            }

            .autocomplete-suggestion {
                padding: 2px 5px;
                white-space: nowrap;
                overflow: hidden;
            }

            .autocomplete-suggestions strong {
                font-weight: normal;
            }

            .autocomplete-group {
                padding: 2px 5px;
            }

            .autocomplete-group strong {
                display: block;
                border-bottom: 1px solid #000;
            }
        </style>
        <style class="js--theme-styles">
            body {
                background-color: #000000; /*base*/
            }

            .controls {
                background: url(/images/ui/Default_Custom/containerbg.png);
                border-image: url(/images/ui/Default_Custom/border.png);
                border-image-slice: 12;
                border-image-repeat: repeat;
            }

            .controls--container--tab__button {
                color: #ded9df; /*base*/
            }

            .footer {
                color: #ded9df; /*base*/
            }

            label {
                background-image: url(/images/ui/Default_Custom/font1.png);
                -webkit-background-clip: text;
	            -webkit-text-fill-color: transparent;
                background-clip: text;
                background-size: 18px;
            }

            button {
                color: #ded9df; /*base*/
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-image: url(/images/ui/Default_Custom/containerbg.png);
            }

            input[type='text'], select, .slider {
                color: #ded9df; /*base*/
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-color: #403842; /*base*/
            }

            .slider::-webkit-slider-thumb {
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-color: #403842; /*base*/
            }

            .slider::-moz-range-thumb {
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background-color: #403842; /*base*/
            }

            .autocomplete-suggestions {
                color: #ded9df; /*base*/
                border-image: url(/images/ui/Default_Custom/border.png) 8 round;
                background: #403842; /*base*/
            }

            .autocomplete-selected {
                background-color: #817084; /*alt*/
            }
            
            .autocomplete-suggestions strong {
                color: #ffea56; /*alt*/
            }
        </style>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css" />
        <script src="/js/force-graph-modded.js"></script>
        <script src="//unpkg.com/d3-quadtree"></script>
        <script src="//unpkg.com/d3-force"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.devbridge-autocomplete/1.4.10/jquery.autocomplete.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-localize/0.1.0/jquery.localize.min.js"></script>
        <script src="/js/conn-type.js"></script>
    </head>
    <body>
        <div class="content">
            <div class="controls controls-top">
                <div class="control">
                    <label data-localize="origin.name" class="noselect">Origin:</label>
                    <input name="startWorld" type="text" class="js--world-input js--start-world" />
                    <label data-localize="destination.name" class="noselect">Destination:</label>
                    <input name="endWorld" type="text" class="js--world-input js--end-world" />
                    <button data-localize="reset" class="js--reset noselect">Reset</button>
                </div>
            </div>
            <div id="graph" class="graph"></div>
            <div class="controls--container--tab">
                <button class="controls--container--tab__button noselect">â–²</button>
            </div>
            <div class="controls--container controls-bottom--container">
                <div class="controls controls-bottom" style="opacity: 0;">
                    <div class="control">
                        <label data-localize="lang.name" class="noselect">Language:</label>
                        <select name="language" class="js--lang">
                            <option data-localize="lang.values.english" value="en" selected>English</option>
                            <option data-localize="lang.values.japanese" value="ja">Japanese</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="uiTheme.name" class="noselect">UI Theme:</label>
                        <select name="uiTheme" class="js--ui-theme">
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="fontStyle.name" class="noselect">Font Style:</label>
                        <select name="fontStyle" class="js--font-style">
                            <option data-localize="fontStyle.values.style1" value="0">Style 1</option>
                            <option data-localize="fontStyle.values.style2" value="1">Style 2</option>
                            <option data-localize="fontStyle.values.style3" value="2">Style 3</option>
                            <option data-localize="fontStyle.values.style4" value="3">Style 4</option>
                            <option data-localize="fontStyle.values.style5" value="4">Style 5</option>
                            <option data-localize="fontStyle.values.style6" value="5">Style 6</option>
                            <option data-localize="fontStyle.values.style7" value="6">Style 7</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="displayMode.name" class="noselect">Display Mode:</label>
                        <select name="displayMode" class="js--display-mode">
                            <option data-localize="displayMode.values.vertical" value="0" selected>Vertical</option>
                            <option data-localize="displayMode.values.horizontal" value="1">Horizontal</option>
                            <option data-localize="displayMode.values.radialIn" value="2">Inward</option>
                            <option data-localize="displayMode.values.radialOut" value="3">Outward</option>
                            <option data-localize="displayMode.values.free" value="4">Free</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="connMode.name" class="noselect">Connection Mode:</label>
                        <select name="connMode" class="js--conn-mode">
                            <option data-localize="connMode.values.oneWay" value="0" selected>One-Way)/option>
                            <option data-localize="connMode.values.twoWay" value="1">Two-Way</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="labelMode.name" class="noselect">Label Display:</label>
                        <select name="labelMode" class="js--label-mode">
                            <option data-localize="labelMode.values.never" value="0">Never</option>
                            <option data-localize="labelMode.values.hover" value="1" selected>On Hover</option>
                            <option data-localize="labelMode.values.select" value="2">On Select</option>
                            <option data-localize="labelMode.values.always" value="3">Always</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="sizeDiff.name" class="noselect">Size Difference:</label>
                        <input type="range" min="1" max="10" value="1" step="0.5" class="js--size-diff slider" />
                    </div>
                    <div class="control js--stack-size--container">
                        <label data-localize="stackSize.name" class="noselect">Stack Threshold:</label>
                        <input type="range" min="5" max="100" value="20" step="1" class="js--stack-size slider" />
                    </div>
                </div>
            </div>
            <div data-localize="footer" class="footer noselect"></div>
            <script>
                $(document).keydown(function (event) {
                    if (event.which === 16)
                        isShift = true;
                    else if (event.which === 17)
                        isCtrl = true;
                });

                $(document).keyup(function (event) {
                    if (event.which === 16)
                        isShift = false;
                    else if (event.which === 17)
                        isCtrl = false;
                });

                let isShift = false;
                let isCtrl = false;

                $.fn.extend({
                    animateCss: function (animation, duration, endCallback) {
                        const animationEnd = "webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend";
                        $(this).removeClass($(this).data("animateCss")).trigger("webkitAnimationEnd");
                        if (!duration)
                            duration = 250;
                        $(this).css({
                            "-webkit-animation-duration": duration + "ms",
                            "animation-duration": duration + "ms"
                        });
                        const classes = "animated " + animation;
                        $(this).data("animateCss", classes);

                        $(this).addClass(classes).one(animationEnd, function () {
                            $(this).off(animationEnd);
                            $(this).css({
                                "-webkit-animation-duration": "initial",
                                "animation-duration": "initial"
                            });
                            if (endCallback)
                                endCallback.apply(this);
                            $(this).removeClass(classes);
                        });

                        return this;
                    }
                });

                CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
                    if (width < 2 * radius) radius = width / 2;
                    if (height < 2 * radius) radius = height / 2;
                    this.moveTo(x + radius, y);
                    this.arcTo(x + width, y, x + width, y + height, radius);
                    this.arcTo(x + width, y + height, x, y + height, radius);
                    this.arcTo(x, y + height, x, y, radius);
                    this.arcTo(x, y, x + width, y, radius);
                    return this;
                };

                CanvasRenderingContext2D.prototype.emoji = function (x, y, scale, emoji) {
                    this.beginPath();
                    
                    switch (emoji) {
                        case "â›”":
                        case "ðŸš«":
                            this.arc(x + 3.125 * scale, y - 2.1 * scale, 3.3 * scale, 0, 2 * Math.PI);
                            break;
                        case "ðŸ”’":
                        case "ðŸ”":
                            const isCondition = emoji === "ðŸ”";
                            this.roundRect(x - 0.21 * scale, y - 2.45 * scale, 5.4 * scale, 3.7 * scale, 0.5 * scale);
                            if (isCondition)
                                this.arc(x + 4.875 * scale, y - 3 * scale, 1.6 * scale, 0, 2 * Math.PI);
                            this.moveTo(x + 0.175 * scale, y - 2.445 * scale);
                            this.arc(x + 2.5 * scale, y - 3.1 * scale, 2.325 * scale, Math.PI, 0);
                            this.lineTo(x + 4.825 * scale, y - 2.445 * scale);
                            if (isCondition) {
                                this.moveTo(x + 5.65 * scale, y - 1.5825 * scale);
                                this.lineTo(x + 5.65 * scale, y + 0.525 * scale);
                                this.lineTo(x + 4.85 * scale, y + 1.2375 * scale);
                                this.lineTo(x + 4.85 * scale, y - 1.5825 * scale);
                            }
                            break;
                        case "ðŸ”‘":
                            this.moveTo(x + 3.75 * scale, y - 2.9 * scale);
                            this.lineTo(x + 6.5 * scale, y - 0.15 * scale);
                            this.lineTo(x + 6.5 * scale, y + 1.2 * scale);
                            this.lineTo(x + 4.85 * scale, y + 1.2 * scale);
                            this.lineTo(x + 4.85 * scale, y + 0.6 * scale);
                            this.lineTo(x + 4.15 * scale, y + 0.6 * scale);
                            this.lineTo(x + 4.15 * scale, y);
                            this.lineTo(x + 3.5 * scale, y);
                            this.lineTo(x + 3.5 * scale, y - 0.6 * scale);
                            this.lineTo(x + 3.1 * scale, y - 0.6 * scale);
                            this.lineTo(x + 2.4 * scale, y - 1.4 * scale);
                            this.arc(x + 1.85 * scale, y - 3.35 * scale, 2.1 * scale, 0.4 * Math.PI, 2.4 * Math.PI)
                            break;
                        case "ðŸš©":
                            this.moveTo(x - 0.05 * scale, y + 1.25 * scale);
                            this.lineTo(x - 0.05 * scale, y - 4.25 * scale);
                            this.arc(x + 0.475 * scale, y - 4.75 * scale, 0.725 * scale, 0.75 * Math.PI, 2.05 * Math.PI);
                            this.lineTo(x + 5.9 * scale, y - 3.1 * scale);
                            this.arc(x + 5.675 * scale, y - 2.775 * scale, 0.375 * scale, 1.5 * Math.PI, 0.4 * Math.PI);
                            this.lineTo(x + 1 * scale, y - 0.8 * scale);
                            this.lineTo(x + 1 * scale, y + 1.25 * scale);
                            break;
                        case "â†©ï¸":
                            this.rect(x - 0.2 * scale, y - 5.425 * scale, 6.675 * scale, 6.675 * scale);
                            break;
                        case "âœ¨":
                            this.moveTo(x + 1.5 * scale, y - 2.64 * scale);
                            this.bezierCurveTo(x + 3.6 * scale, y - 2.15 * scale, x + 3.35 * scale, y - 4.7 * scale, x + 3.35 * scale, y - 4.7 * scale);
                            this.arc(x + 3.85 * scale, y - 4.8 * scale, 0.5 * scale, Math.PI, 2 * Math.PI);
                            this.bezierCurveTo(x + 4.05 * scale, y - 2.25 * scale, x + 6 * scale, y - 2.5 * scale, x + 6 * scale, y - 2.5 * scale);
                            this.arc(x + 6 * scale, y - 2 * scale, 0.5 * scale, 1.5 * Math.PI, 0.5 * Math.PI);
                            this.bezierCurveTo(x + 4.05 * scale, y - 1.75 * scale, x + 4.35 * scale, y + 0.7 * scale, x + 4.35 * scale, y + 0.7 * scale);
                            this.arc(x + 3.85 * scale, y + 0.8 * scale, 0.5 * scale, 0, Math.PI);
                            this.bezierCurveTo(x + 3.6 * scale, y - 1.75 * scale, x + 1.5 * scale, y - 1.5 * scale, x + 1.5 * scale, y - 1.5 * scale);
                            this.roundRect(x - 0.2 * scale, y - 3.35 * scale, 2.65 * scale, scale, 0.5 * scale);
                            this.roundRect(x + 0.6 * scale, y - 4.4 * scale, 1.05 * scale, 3.1 * scale, 0.5 * scale);
                            this.rect(x + 2.6 * scale, y - 1.2 * scale, 0.4 * scale, 0.4 * scale);
                            this.roundRect(x + 0.85 * scale, y - 0.85 * scale, 2.65 * scale, scale, 0.5 * scale);
                            this.roundRect(x + 1.65 * scale, y - 1.9 * scale, 1.05 * scale, 3.1 * scale, 0.5 * scale);
                            break;
                        case "ðŸ€":
                            this.arc(x + 1 * scale, y - 3.325 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 2.125 * scale, y - 4.4 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 4.1 * scale, y - 4.4 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 5.225 * scale, y - 3.325 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 0.875 * scale, y - 1.375 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 1.975 * scale, y - 0.275 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 3.125 * scale, y + 0.7 * scale, 0.575 * scale, 0, 2 * Math.PI);
                            this.arc(x + 5.375 * scale, y - 1.375 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 4.225 * scale, y - 0.275 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.lineTo(x + 3.5 * scale, y + 0.85 * scale);
                            this.lineTo(x + 2 * scale, y + 0.85 * scale);
                            this.rect(x + 1.5 * scale, y - 3.5 * scale, 3.25 * scale, 4 * scale);
                            break;
                    }
                    this.closePath();
                };

                function hueToRGB(h) {
                    let s = 1, v = 1, r, g, b, i, f, p, q, t;
                    i = Math.floor(h * 6);
                    f = h * 6 - i;
                    p = v * (1 - s);
                    q = v * (1 - f * s);
                    t = v * (1 - (1 - f) * s);
                    switch (i % 6) {
                        case 0: r = v, g = t, b = p; break;
                        case 1: r = q, g = v, b = p; break;
                        case 2: r = p, g = v, b = t; break;
                        case 3: r = p, g = q, b = v; break;
                        case 4: r = t, g = p, b = v; break;
                        case 5: r = v, g = p, b = q; break;
                    }
                    return "rgb(" + Math.round(r * 255) + "," + Math.round(g * 255) + "," + Math.round(b * 255) + ")";
                }

                function getFontColor(fontStyle, callback) {
                    const uiTheme = config.uiTheme;
                    if (!uiThemeFontColors[uiTheme]) {
                        uiThemeFontColors[uiTheme] = {};
                    }
                    let pixel = uiThemeFontColors[uiTheme][fontStyle];
                    if (pixel)
                        return callback("rgba(" + pixel[0] + ", " + pixel[1] + ", " + pixel[2] + ", 1)");
                    const img = new Image();
                    img.onload = function () {
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        context.drawImage(img, 0, 0);
                        pixel = context.getImageData(0, 8, 1, 1).data;
                        callback("rgba(" + pixel[0] + ", " + pixel[1] + ", " + pixel[2] + ", 1)");
                        uiThemeFontColors[uiTheme][fontStyle] = [ pixel[0], pixel[1], pixel[2] ];
                        canvas.remove();
                    };
                    img.src = "./images/ui/" + config.uiTheme + "/font" + (fontStyle + 1) + ".png";
                }

                function getBaseBgColor(uiTheme, callback) {
                    const img = new Image();
                    img.onload = function () {
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        context.drawImage(img, 0, 0);
                        const pixel = context.getImageData(0, 0, 1, 1).data;
                        const pixel2 = context.getImageData(4, 4, 1, 1).data;
                        const pixel3 = context.getImageData(8, 8, 1, 1).data;
                        const r = Math.round((pixel[0] + pixel2[0] + pixel3[0]) / 3);
                        const g = Math.round((pixel[1] + pixel2[1] + pixel3[1]) / 3);
                        const b = Math.round((pixel[2] + pixel2[2] + pixel3[2]) / 3);
                        callback("rgba(" + r + ", " + g + ", " + b + ", 1)");
                        canvas.remove();
                    };
                    img.src = "./images/ui/" + uiTheme + "/containerbg.png";
                }

                let worldData;

                function loadOrInitConfig() {
                    try {
                        if (!window.localStorage.hasOwnProperty("config")) {
                            window.localStorage.setItem("config", JSON.stringify(config));
                        } else {
                            const savedConfig = JSON.parse(window.localStorage.getItem("config"));
                            const configKeys = Object.keys(savedConfig);
                            for (let c in configKeys) {
                                const key = configKeys[c];
                                if (config.hasOwnProperty(key)) {
                                    const value = savedConfig[key];
                                    config[key] = value;
                                    switch (key) {
                                        case "lang":
                                            $(".js--lang").val(value);
                                            break;
                                        case "uiTheme":
                                            $(".js--ui-theme").val(value);
                                            break;
                                        case "fontStyle":
                                            $(".js--font-style").val(value);
                                            break;
                                        case "displayMode":
                                            $(".js--display-mode").val(value);
                                            if (parseInt(value) >= 2)
                                                $(".js--stack-size--container").css("display", "none");
                                            break;
                                        case "connMode":
                                            $(".js--conn-mode").val(value);
                                            break;
                                        case "labelMode":
                                            $(".js--label-mode").val(value);
                                            break;
                                        case "sizeDiff":
                                            $(".js--size-diff").val(value);
                                            break;
                                        case "stackSize":
                                            $(".js--stack-size").val(value);
                                            break;
                                    }
                                }
                            }
                        }
                    } catch (error) {
                    }
                }

                function updateConfig() {
                    try {
                        window.localStorage.config = JSON.stringify(config);
                    } catch (error) {
                    }
                }

                function updateControlsContainer() {
                    const controlsHeight = $(".controls-bottom").outerHeight();
                    $(".controls--container").css({ "height": controlsHeight + "px", "margin-top": "-" + (controlsHeight + 20) + "px" });
                    $(".controls--container--tab").css({ "height": controlsHeight + "px", "left": "calc(50% - " + (($(".controls--container--tab").outerWidth() - 16) / 2) + "px)" });
                }

                function loadWorldData(update, callback) {
                    $.get("/worlds" + (update ? "?update=true" : ""), function (data) {
                        callback(data);
                    });
                }

                let graph;
                
                let selectedWorldId;

                let localizedConns;
                
                let effectsJP;

                let uiThemeFontColors = {};

                let config = {
                    lang: "en",
                    uiTheme: "Default_Custom",
                    fontStyle: 0,
                    displayMode: 0,
                    connMode: 0,
                    labelMode: 1,
                    sizeDiff: 1,
                    stackSize: 20
                };

                function initGraph(displayMode, paths) {

                    let visibleWorldIds;
                    
                    const links = [];

                    const oneWayLinks = [];

                    let lastOneWayLinkKey;

                    let dashOffset = 0;

                    const addedLinks = [];

                    const worldScales = {};

                    const dagIgnore = {};

                    _.each(worldData, w => {
                        worldScales[w.id] = 1 + (Math.round((w.size - minSize) / (maxSize - minSize) * 10 * (config.sizeDiff - 1)) / 10);
                    });

                    if (paths) {
                        visibleWorldIds = _.uniq(_.flatten(paths).map(p => p.id));
                        const pathScores = [];
                        let minPathDepth = paths[0].length - 2;
                        let maxPathDepth;
                        let depthDiff;
                        let maxPathScore;
                        for (let pi in paths) {
                            const path = paths[pi];
                            if (path.length - 2 > minPathDepth * 2) {
                                let visibleWorldIdRemovalCandidates = _.uniq(_.flatten(paths.slice(pi)).map(p => p.id));
                                paths = paths.slice(0, pi);
                                let requiredWorldIds = _.uniq(_.flatten(paths).map(p => p.id));
                                _.remove(visibleWorldIdRemovalCandidates, w => requiredWorldIds.indexOf(w) > -1);
                                _.remove(visibleWorldIds, w => visibleWorldIdRemovalCandidates.indexOf(w) > -1);
                                break;
                            }
                            pathScores[pi] = parseInt(pi) + 3 * ((path.length - 2) - minPathDepth);
                        }
                        maxPathDepth = paths[paths.length - 1].length;
                        depthDiff = maxPathDepth - minPathDepth;
                        maxPathScore = ((paths.length - 1) + (3 * depthDiff)) * (depthDiff > 0 ? 1 : 2) || 1;
                        if (paths.length === 1 && paths[0][0].connType & ConnType.INACCESSIBLE)
                            pathScores[0] = maxPathScore;
                        for (let p in paths) {
                            const path = paths[p];
                            for (let w = 1; w < path.length; w++) {
                                const sourceId = path[w - 1].id;
                                const targetId = path[w].id;
                                const linkId = `${sourceId}_${targetId}`;
                                if (addedLinks.indexOf(linkId) === -1) {
                                    dagIgnore[sourceId] = [];
                                    const link = {
                                        key: linkId,
                                        source: sourceId,
                                        target: targetId,
                                        sourceScale: worldScales[sourceId],
                                        targetScale: worldScales[targetId],
                                        connType: path[w - 1].connType,
                                        typeParams: path[w - 1].typeParams,
                                        icons: [],
                                        hidden: false,
                                        defaultColor: hueToRGB(0.6666 - ((pathScores[p] / maxPathScore) * 0.6666)),
                                        connTypeCheck: path[w - 1].connType ? 'replace' : undefined
                                    };
                                    links.push(link);
                                    addedLinks.push(linkId);
                                    if (path[w - 1].connType & ConnType.ONE_WAY)
                                        oneWayLinks.push(link);
                                }
                            }
                        }
                    } else {
                        visibleWorldIds = Object.keys(worldData).map(id => parseInt(id));

                        const maxDepth =  _.max(worldData.map(w => w.depth));

                        for (let w in visibleWorldIds) {
                            const world = worldData[visibleWorldIds[w]];
                            const connections = world.connections;
                            const dagIgnoreIds = dagIgnore[world.id] = [];
                            for (let c in connections) {
                                const conn = connections[c];
                                const connWorld = worldData[conn.targetId];
                                let hidden = false;
                                if (conn.type & ConnType.NO_ENTRY)
                                    hidden = true;
                                else if (world.depth >= connWorld.depth) {
                                    const sameDepth = world.depth === connWorld.depth;
                                    const reverseConn = connWorld.connections.filter(c => c.targetId === world.id);
                                    hidden = (!sameDepth && !reverseConn.length) || (reverseConn.length && !(reverseConn[0].type & ConnType.NO_ENTRY) && (!sameDepth || (!(conn.type & ConnType.ONE_WAY) && world.id > connWorld.id)));
                                    dagIgnoreIds.push(connWorld.id);
                                }
                                if (hidden)
                                    dagIgnoreIds.push(connWorld.id);
                                const link = {
                                    key: `${world.id}_${connWorld.id}`,
                                    source: world.id,
                                    target: connWorld.id,
                                    sourceScale: worldScales[world.id],
                                    targetScale: worldScales[connWorld.id],
                                    connType: conn.type,
                                    typeParams: conn.typeParams,
                                    icons: [],
                                    hidden: hidden,
                                    defaultColor: hueToRGB(0.6666 - ((world.depth / (maxDepth - 1)) * 0.6666)),
                                    connTypeCheck: conn.type ? hidden ? 'after' : 'replace' : undefined
                                };
                                links.push(link);
                                if (!hidden && conn.type & ConnType.ONE_WAY)
                                    oneWayLinks.push(link);
                            }
                        }
                    }
                    oneWayLinks.length && (lastOneWayLinkKey = oneWayLinks[oneWayLinks.length - 1].key);

                    links.forEach(l => {
                        const icons = l.icons;
                        const connType = l.connType;
                        if (connType & ConnType.INACCESSIBLE)
                            icons.push(getConnTypeIcon(ConnType.INACCESSIBLE));
                        else {
                            if (connType & ConnType.ONE_WAY)
                                icons.push(getConnTypeIcon(ConnType.ONE_WAY));
                            else if (connType & ConnType.NO_ENTRY)
                                icons.push(getConnTypeIcon(ConnType.NO_ENTRY));
                            if (connType & ConnType.UNLOCK)
                                icons.push(getConnTypeIcon(ConnType.UNLOCK));
                            else if (connType & ConnType.LOCKED)
                                icons.push(getConnTypeIcon(ConnType.LOCKED));
                            else if (connType & ConnType.LOCKED_CONDITION)
                                icons.push(getConnTypeIcon(ConnType.LOCKED_CONDITION, l.typeParams[ConnType.LOCKED_CONDITION]));
                            if (connType & ConnType.DEAD_END)
                                icons.push(getConnTypeIcon(ConnType.DEAD_END));
                            else if (connType & ConnType.ISOLATED)
                                icons.push(getConnTypeIcon(ConnType.ISOLATED));
                            if (connType & ConnType.EFFECT)
                                icons.push(getConnTypeIcon(ConnType.EFFECT, l.typeParams[ConnType.EFFECT]));
                            if (connType & ConnType.CHANCE)
                                icons.push(getConnTypeIcon(ConnType.CHANCE, l.typeParams[ConnType.CHANCE]));
                        }
                    });

                    const images = (paths ? worldData.filter(w => visibleWorldIds.indexOf(w.id) > -1) : worldData)
                        .map(d => {
                            const img = new Image();
                            img.id = d.id;
                            img.title = config.lang === "en" || !d.titleJP ? d.title : d.titleJP;
                            img.src = `./images/worlds/${d.filename}`;
                            return img;
                        });

                    const radius = 12;
                
                    const gData = {
                        nodes: images.map(img => {
                            const id = parseInt(img.id);
                            const scale = worldScales[id];
                            const ret = { id: id, img, isHover: false, scale: scale };
                            ret.globalDepth = worldData[id].depth;
                            ret.dagIgnore = dagIgnore[id];
                            ret.width = 16 * scale;
                            ret.height = 12 * scale;
                            return ret;
                        }),
                        links: links
                    };

                    let nodeDepths;

                    let depthDistances;

                    const elem = document.getElementById('graph');
                
                    graph = ForceGraph()(elem);
                    if (displayMode < 4) {
                        graph = graph
                            .dagMode(displayMode === 0 ? 'td' : displayMode === 1 ? 'lr' : displayMode === 2 ? 'radialin' : 'radialout')
                            .dagLevelDistance(displayMode < 2 ? 12 : 24 + radius * (config.sizeDiff + 1));
                    }
                    graph
                        .nodeCanvasObject(({ id, img, x, y, scale, width, height, isHover }, ctx, globalScale) => {
                            ctx.imageSmoothingEnabled = false;
                            ctx.drawImage(img, 0, 0, img.width, img.height, x - width / 2, y - height / 2, width, height);
                            if (config.labelMode === 3 || (config.labelMode === 1 && isHover) || (config.labelMode === 2 && id === selectedWorldId)) {
                                ctx.lineWidth = 0.25 * scale;
                                ctx.strokeStyle = "#000000";
                                ctx.fillStyle = "#ded9df";
                                ctx.font = (2 * scale) + "px 'MS Gothic'";
                                const world = worldData[id];
                                const worldName = config.lang === "en" || !world.titleJP ? world.title : world.titleJP;
                                let textLines = worldName.split(" ");
                                for (let l = 0; l < textLines.length; l++) {
                                    if (ctx.measureText(textLines[l]).width < width) {
                                        let mergeIndex = 0;
                                        for (let l2 = l + 1; l2 < textLines.length; l2++) {
                                            const mergedLine = textLines.slice(l, l2 + 1).join(" ");
                                            if (ctx.measureText(mergedLine).width < width) {
                                                mergeIndex = l2;
                                            } else
                                                break;
                                        }
                                        if (mergeIndex) {
                                            textLines = textLines.slice(0, l).concat([textLines.slice(l, mergeIndex + 1).join(" ")], textLines.slice(mergeIndex + 1));
                                        }
                                    } else if (textLines[l].indexOf("ï¼š") > -1)
                                        textLines = textLines.slice(0, l).concat(textLines[l].replace(/ï¼š/g, "ï¼š ").split(" ")).concat(textLines.slice(l + 1));
                                }
                                for (let l in textLines) {
                                    const textLine = textLines[l];
                                    const lineWidth = ctx.measureText(textLine).width;
                                    const lineX = x - lineWidth / 2;
                                    const lineY = (y + 0.5 * scale) - (textLines.length - 1) + l * 2 * scale;
                                    ctx.strokeText(textLine, lineX, lineY);
                                    ctx.fillText(textLine, lineX, lineY);
                                }
                            }
                            if (selectedWorldId == id) {
                                ctx.strokeStyle = '#f00';
                                ctx.lineWidth = 1 / globalScale;
                                ctx.strokeRect(x - width / 2, y - height / 2, width, height);
                            }
                            if (isHover && (isShift || isCtrl)) {
                                ctx.fillText("ðŸ”—", x + (width / 2) - 3.5, y - (height / 2) + 2.5);
                            }
                        })
                        .nodeVal(node => node.height)
                        .nodeLabel(node => node.img.title)
                        .nodesPerStack(config.stackSize)
                        .linkWidth(link => selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? 2 : 1)
                        .linkColor(link => link.hidden ? 'transparent' : selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? '#f00' : link.defaultColor)
                        .linkCanvasObjectMode('connTypeCheck')
                        .linkCanvasObject((link, ctx, globalScale) => {
                            const hidden = link.hidden;
                            if (hidden && config.connMode === 0)
                                return;
                            const connType = link.connType;
                            if (!hidden) {
                                ctx.beginPath();
                                ctx.lineWidth = (selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? 2 : 1) / globalScale;
                                ctx.strokeStyle = selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? '#f00' : link.defaultColor;
                                if (connType && connType & ConnType.ONE_WAY) {
                                    let currentDashOffset = dashOffset;
                                    if (link.key === lastOneWayLinkKey)
                                        dashOffset = dashOffset < 9.8 ? dashOffset + 0.2 : 0;
                                    ctx.setLineDash([5, 5]);
                                    ctx.lineDashOffset = currentDashOffset * -1;
                                }
                            }
                            const sourceX = link.source.x;
                            const sourceY = link.source.y;
                            const targetX = link.target.x;
                            const targetY = link.target.y;
                            if (!hidden) {
                                ctx.moveTo(sourceX, sourceY);
                                ctx.lineTo(targetX, targetY);
                                ctx.stroke();
                                ctx.closePath();
                            }
                            if (link.icons.length)
                                drawLinkIcons(link, ctx, globalScale);
                        })
                        .onNodeHover((node, prevNode) => {
                            elem.style.cursor = node ? 'pointer' : null;
                            if (node)
                                node.isHover = true;
                            if (prevNode)
                                prevNode.isHover = false;
                        })
                        .onNodeClick(node => {
                            if (isCtrl || isShift) {
                                const world = worldData[node.id];
                                window.open(config.lang === "en" || !world.titleJP
                                    ? 'https://yume2kki.fandom.com/wiki/' + world.title
                                    : ('https://wikiwiki.jp/yume2kki-t/' + (world.titleJP.indexOf("ï¼š") > -1 ? world.titleJP.slice(0, world.titleJP.indexOf("ï¼š")) : world.titleJP)),
                                    "_blank", isShift ? "width=" + window.outerWidth + ",height=" + window.outerHeight : "");
                            } else {
                                // Center/zoom on node
                                selectedWorldId = node && (!selectedWorldId || selectedWorldId !== node.id) ? node.id : null;
                                graph.centerAt(node.x, node.y, 1000);
                                graph.zoom(8, 1000);
                            }
                        })
                        .iconLabel(icon => {
                            return icon.text;   
                        })
                        .cooldownTime(Infinity)
                        // Deactivate existing forces
                        // Add collision and bounding box forces
                        .d3Force('collide', d3.forceCollide((node) => radius * worldScales[node.id]))
                        .d3Force('box', () => {
                            const SQUARE_HALF_SIDE = radius * 50;

                            gData.nodes.forEach(node => {
                                const x = node.x || 0, y = node.y || 0;

                                // bounce on box walls
                                if (Math.abs(x) > SQUARE_HALF_SIDE) { node.vx += 0.1 * (x > 0 ? -1 : 1); }
                                if (Math.abs(y) > SQUARE_HALF_SIDE) { node.vy += 0.1 * (y > 0 ? -1 : 1); }
                            });
                        })
                        .graphData(gData);
                }

                function getConnTypeIcon(connType, typeParams) {
                    const localizedConn = localizedConns[connType];
                    const char = getConnTypeChar(connType);
                    const name = localizedConn.name;
                    let description = localizedConn.description;
                    if (description) {
                        switch (connType) {
                            case ConnType.EFFECT:
                                description = typeParams && ((config.lang === 'en' && typeParams.params) || (config.lang !== 'en' && typeParams.paramsJP))
                                    ? description.replace('{0}', config.lang === 'en' ? typeParams.params : typeParams.paramsJP)
                                    : null;
                                break;
                            case ConnType.CHANCE:
                                description = typeParams && typeParams.params
                                    ? description.replace('{0}', config.lang === 'en' ? typeParams.params : typeParams.params.replace('%', 'ï¼…'))
                                    : '';
                                break;
                            case ConnType.LOCKED_CONDITION:
                                description = typeParams && ((config.lang === 'en' && typeParams.params) || (config.lang !== 'en' && typeParams.paramsJP))
                                    ? description.replace('{0}', config.lang === 'en' ? typeParams.params : typeParams.paramsJP)
                                    : '';
                                break;
                        }
                    }
                    return {
                        char: char,
                        text: name + (description ? (config.lang === 'en' ? ' - ' : 'ï¼š') + description : '')
                    };
                }

                function getConnTypeChar(connType) {
                    let char;
                    switch (connType) {
                        case ConnType.ONE_WAY:
                            char = "âžœ";
                            break;
                        case ConnType.NO_ENTRY:
                            char = "â›”";
                            break;
                        case ConnType.UNLOCK:
                            char = "ðŸ”‘";
                            break;
                        case ConnType.LOCKED:
                            char = "ðŸ”’";
                            break;
                        case ConnType.DEAD_END:
                            char = "ðŸš©";
                            break;
                        case ConnType.ISOLATED:
                            char = "â†©ï¸";
                            break;
                        case ConnType.EFFECT:
                            char = "âœ¨";
                            break;
                        case ConnType.CHANCE:
                            char = "ðŸ€";
                            break;
                        case ConnType.LOCKED_CONDITION:
                            char = "ðŸ”";
                            break;
                        case ConnType.INACCESSIBLE:
                            char = "ðŸš«";
                            break;
                    }
                    return char;
                }

                function drawLinkIcons(link, ctx, globalScale) {
                    const sourceScale = link.sourceScale;
                    const targetScale = link.targetScale;
                    const connType = link.connType;
                    const icons = link.icons;
                    let sourceX = link.source.x;
                    let sourceY = link.source.y;
                    let targetX = link.target.x;
                    let targetY = link.target.y;
                    let tempSourceX = sourceX;
                    let tempSourceY = sourceY;
                    let tempTargetX = targetX;
                    let tempTargetY = targetY;
                    /*ctx.save();
                    ctx.beginPath();
                    var style = ctx.strokeStyle;
                    var lwidth = ctx.lineWidth;
                    ctx.strokeStyle = "rgba(255, 0, 0, 1)";
                    ctx.lineWidth = 0.1;*/
                    let gapSize;
                    const scale = globalScale < 24 ? 1 : 24 / globalScale;
                    const isX = Math.abs(targetX - sourceX) >= Math.abs(targetY - sourceY);
                    if (isX) {
                        const addSourceCoord = (sourceX < targetX ? 8 : -8) * sourceScale;
                        const addTargetCoord = (targetX < sourceX ? 8 : -8) * targetScale;
                        sourceX += addSourceCoord;
                        sourceY = sourceY + (tempTargetY - tempSourceY)/(tempTargetX - tempSourceX) * addSourceCoord;
                        targetX += addTargetCoord;
                        targetY = targetY + (tempSourceY - tempTargetY)/(tempSourceX - tempTargetX) * addTargetCoord;
                        gapSize = Math.max(Math.min(((sourceX < targetX ? targetX - sourceX : sourceX - targetX) - 16 * scale) / icons.length - 1, 8 * scale), 0);
                    } else {
                        const addSourceCoord = (sourceY < targetY ? 6 : -6) * sourceScale;
                        const addTargetCoord = (targetY < sourceY ? 6 : -6) * targetScale;
                        sourceY += addSourceCoord;
                        sourceX = sourceX + (tempTargetX - tempSourceX)/(tempTargetY - tempSourceY) * addSourceCoord;
                        targetY += addTargetCoord;
                        targetX = targetX + (tempSourceX - tempTargetX)/(tempSourceY - tempTargetY) * addTargetCoord;
                        gapSize = Math.max(Math.min(((sourceY < targetY ? targetY - sourceY : sourceY - targetY) - 16 * scale) / icons.length - 1, 8 * scale), 0);
                    }
                    /*ctx.arc(sourceX, sourceY, 0.3, 0, 2 * Math.PI)
                    ctx.stroke();
                    ctx.closePath();
                    ctx.beginPath();
                    ctx.strokeStyle = "rgba(0, 0, 255, 1)";
                    ctx.arc(targetX, targetY, 0.3, 0, 2 * Math.PI)
                    ctx.stroke();
                    ctx.closePath();
                    ctx.restore();
                    ctx.strokeStyle = style;
                    ctx.lineWidth = lwidth;*/
                    ctx.fillStyle = "#fff";
                    ctx.font = (scale * 6) + "px 'MS Gothic'";
                    const textBaseX = (sourceX * 1.5 + targetX * 0.5) / 2;
                    const textBaseY = (sourceY * 1.5 + targetY * 0.5) / 2;
                    for (let e = 0; e < icons.length; e++) {
                        const emoji = icons[e].char;
                        let textX, textY;
                        const addCoord = gapSize * ((icons.length * -0.5) + e + 0.5); //e * gapSize;
                        if (isX) {
                            textX = (textBaseX + addCoord) - 3.5 * scale;
                            textY = textBaseY + (targetY - sourceY)/(targetX - sourceX) * addCoord;
                        } else {
                            textY = textBaseY + addCoord;
                            textX = (textBaseX + (targetX - sourceX)/(targetY - sourceY) * addCoord) - 3.5 * scale;
                        }
                        /*if (isX) {
                            textX = ((sourceX + 8 * scale) + addCoord) - 3.5 * scale;
                            textY = sourceY + (targetY - sourceY)/(targetX - sourceX) * addCoord;
                        } else {
                            textY = ((sourceY + 8 * scale) + addCoord)
                            textX = (sourceX + (targetX - sourceX)/(targetY - sourceY) * addCoord) - 3.5 * scale;;
                        }*/
                        if (e === 0 && connType & ConnType.ONE_WAY) {
                            ctx.beginPath();
                            ctx.setLineDash([0, 0]);
                            if (sourceX >= targetX) {
                                ctx.save();
                                ctx.scale(-1, 1);
                                textX += 7 * scale;
                                ctx.strokeStyle = "#000";
                                ctx.lineWidth = 0.2 * scale;
                                ctx.roundRect(-textX - 0.25 * scale, textY - 5.5 * scale, 6.5 * scale, 6.5 * scale, 0.5 * scale);
                                ctx.fill();
                                ctx.stroke();
                                ctx.fillStyle = "#000";
                                ctx.fillText(emoji, -textX, textY);
                                ctx.fillStyle = "#fff";
                                ctx.restore();
                            } else {
                                ctx.strokeStyle = "#000";
                                ctx.lineWidth = 0.2 * scale;
                                ctx.roundRect(textX - 0.25 * scale, textY - 5.5 * scale, 6.5 * scale, 6.5 * scale, 0.5 * scale);
                                ctx.fill();
                                ctx.stroke();
                                ctx.fillStyle = "#000";
                                ctx.fillText(emoji, textX, textY);
                                ctx.fillStyle = "#fff";
                            }
                            ctx.closePath();
                        } else
                            ctx.fillText(emoji, textX, textY);
                    }
                }

                function reloadGraph() {
                    const startVal = $(".js--start-world").val();
                    const endVal = $(".js--end-world").val();
                    const startWorld = startVal && worldNames.indexOf(startVal) > -1 ? worldsByName[startVal] : null;
                    const endWorld = endVal && worldNames.indexOf(endVal) > -1 ? worldsByName[endVal] : null;
                    const matchPaths = startWorld && endWorld && startWorld != endWorld
                        ? findPath(startWorld.id, endWorld.id, ConnType.NO_ENTRY | ConnType.DEAD_END | ConnType.ISOLATED)
                        : null;
                    if (graph)
                        graph._destructor();
                    initGraph(config.displayMode, matchPaths)
                }

                let mult = 1;

                function findPath(s, t, ignoreTypeFlags) {
                    const startTime = performance.now();

                    const checkedSourceNodes = [s];
                    const checkedTargetNodes = [t];

                    const source = worldData[s];
                    const target = worldData[t];

                    let matchPaths = [];

                    let sourcePaths = {};
                    let targetPaths = {};

                    let nextGenSourceWorlds = [source];
                    let nextGenTargetWorlds = [target];

                    let genIndex = 0;

                    sourcePaths[s] = [{ id: s, connType: null }];
                    targetPaths[t] = [{ id: t, connType: null }];
                  
                    while (genIndex <= 20) {
                        let sourceWorlds = nextGenSourceWorlds.slice(0);
                        let targetWorlds = nextGenTargetWorlds.slice(0);
                        nextGenSourceWorlds = [];
                        nextGenTargetWorlds = [];
                        for (let sw in sourceWorlds) {
                            const sourceWorld = sourceWorlds[sw];
                            const sourcePath = sourcePaths[sourceWorld.id];
                            //delete sourcePaths[sourceWorld.id];
                            const sourceConns = traverseConns(checkedSourceNodes, sourcePath, nextGenSourceWorlds, sourceWorld, ignoreTypeFlags, true);
                            $.extend(sourcePaths, sourceConns);
                        }
                        for (let tw in targetWorlds) {
                            const targetWorld = targetWorlds[tw];
                            const targetPath = targetPaths[targetWorld.id];
                            //delete targetPaths[targetWorld.id];
                            const targetConns = traverseConns(checkedTargetNodes, targetPath, nextGenTargetWorlds, targetWorld, ignoreTypeFlags, false);
                            $.extend(targetPaths, targetConns);
                        }
                        
                        genIndex++;

                        /*let checkedSourceIds = Object.keys(sourcePaths).map(id => parseInt(id));
                        let checkedTargetIds = Object.keys(targetPaths).map(id => parseInt(id));*/

                        $.grep(checkedSourceNodes, id => {
                            const ret = $.inArray(id, checkedTargetNodes) !== -1;
                            if (ret) {
                                let skip = false;

                                let sourcePath = _.cloneDeep(sourcePaths[id]);
                                let targetPath = _.cloneDeep(targetPaths[id]);

                                if (sourcePath[sourcePath.length - 1].id === id && targetPath[targetPath.length - 1].id === id) {
                                    sourcePath = sourcePath.slice(0, -1);
                                }

                                let loopWorldIds, sourcePathIds, targetPathIds;
                                while ((loopWorldIds = _.intersectionWith((sourcePathIds = sourcePath.map(sp => sp.id)), (targetPathIds = targetPath.map(tp => tp.id)), _.isEqual)).length) {
                                    //console.log("Loop found", worldData[loopWorldIds[0]].title, JSON.stringify(sourcePath.map(function(p) { return worldData[p].title})), JSON.stringify(targetPath.map(function(p) { return worldData[p].title})));
                                    sourcePath = sourcePath.slice(0, sourcePathIds.indexOf(loopWorldIds[0]));
                                    targetPath = targetPath.slice(0, targetPathIds.indexOf(loopWorldIds[0]) + 1);
                                    //console.log("Loop fixed", worldData[loopWorldIds[0]].title, JSON.stringify(sourcePath.map(function(p) { return worldData[p].title})), JSON.stringify(targetPath.map(function(p) { return worldData[p].title})));
                                }
                                
                                const matchPath = sourcePath.concat(targetPath.reverse());
                                for (let p in matchPaths) {
                                    for (let w = 1; w < matchPaths[p].length; w++) {
                                        const linkId = `${matchPaths[p][w - 1].id}_${matchPaths[p][w].id}`;
                                        for (let m = 1; m < matchPath.length; m++) {
                                            const matchLinkId = `${matchPath[m - 1].id}_${matchPath[m].id}`;
                                            if (linkId === matchLinkId) {
                                                skip = true;
                                                break;
                                            }
                                        }
                                        if (skip)
                                            break;
                                    }
                                    if (skip)
                                        break;
                                }
                                if (skip)
                                    return false;
                                _.remove(nextGenSourceWorlds, w => w.id === id);
                                _.remove(nextGenTargetWorlds, w => w.id === id);
                                matchPaths.push(matchPath);
                            }
                            return ret;
                        });
                    }

                    const endTime = performance.now();

                    console.log("Found", matchPaths.length, "matching path(s) in", Math.round((endTime - startTime) * 10) / 10, "ms");

                    if (!matchPaths.length) {
                        if (ignoreTypeFlags & ConnType.DEAD_END)
                            ignoreTypeFlags ^= (ConnType.DEAD_END | ConnType.ISOLATED);
                        else
                            ignoreTypeFlags = 0;
                        if (ignoreTypeFlags)
                            return findPath(s, t, ignoreTypeFlags);
                        else {
                            matchPaths = [ [ { id: s, connType: ConnType.INACCESSIBLE }, { id: t, connType: null } ] ];
                            return matchPaths;
                        }
                    } else {
                        if ((!(ignoreTypeFlags & ConnType.LOCKED) && _.every(matchPaths, mp => mp.filter(p => p.connType && p.connType & (ConnType.LOCKED | ConnType.LOCKED_CONDITION).length)))) {
                            const additionalPaths = findPath(s, t, (ignoreTypeFlags = ignoreTypeFlags | ConnType.LOCKED | ConnType.LOCKED_CONDITION));
                            if (additionalPaths.length && !(additionalPaths[0][0].connType & ConnType.INACCESSIBLE)) {
                                for (let ap in additionalPaths)
                                    matchPaths.push(additionalPaths[ap]);
                            }
                        }
                        matchPaths = _.sortBy(matchPaths, [ 'length' ]);
                        if (matchPaths.length > 5)
                            matchPaths = matchPaths.slice(0, 5);
                    }

                    return matchPaths;
                }

                function traverseConns(checkedNodes, path, nextGenWorlds, world, ignoreTypeFlags, isSource) {
                    const ret = {};
                    const conns = world.connections;
                    for (let c in conns) {
                        let connType = conns[c].type;
                        const typeParams = conns[c].typeParams;
                        if (isSource && connType & ignoreTypeFlags)
                            continue;
                        const connWorld = worldData[conns[c].targetId];
                        const id = connWorld.id;
                        if (checkedNodes.indexOf(id) === -1) {
                            // If checking from target
                            if (isSource) {
                                path[path.length - 1].connType = connType;
                                path[path.length - 1].typeParams = typeParams;
                                connType = null;
                            } else {
                                const reverseConn = connWorld.connections.filter(c => c.targetId === world.id);
                                let reverseConnType = 0;
                                if (reverseConn.length)
                                    reverseConnType = reverseConn[0].type;
                                else {
                                    if (connType & ConnType.ONE_WAY)
                                        reverseConnType |= ConnType.DEAD_END;
                                    else if (connType & ConnType.NO_ENTRY)
                                        reverseConnType |= ConnType.ONE_WAY;
                                    if (connType & ConnType.LOCKED)
                                        reverseConnType |= ConnType.UNLOCK;
                                    else if (connType & ConnType.UNLOCK)
                                        reverseConnType |= ConnType.LOCKED;
                                    if (connType & ConnType.DEAD_END)
                                        reverseConnType |= ConnType.ISOLATED;
                                    else if (connType & ConnType.ISOLATED)
                                        reverseConnType |= ConnType.DEAD_END;
                                }
                                connType = reverseConnType;
                                if (connType & ignoreTypeFlags)
                                    continue;
                            }
                            const connPath = path.slice(0);
                            connPath.push({
                                id: id,
                                connType: connType,
                                typeParams: typeParams
                            });
                            ret[id] = connPath;
                            checkedNodes.push(id);
                            nextGenWorlds.push(worldData[id]);
                        }
                    }
                    return ret;
                }

                function findConnectionAnomalies() {
                    const connData = {};
                    worldData.forEach(w => {
                        connData[w.id] = [];
                        worldData[w.id].connections.map(c => worldData[c.targetId]).forEach(c => {
                            connData[w.id].push(c.id);
                        });
                    }); 
                    Object.keys(connData).forEach(id => {
                        let connIds = connData[id].slice(0);
                        connIds.forEach(c => {
                            const index = connData[c].indexOf(parseInt(id));
                            if (index > -1) {
                                connData[id].splice(connData[id].indexOf(c), 1);
                                connData[c].splice(index, 1);
                            }
                        });
                    });
                    Object.keys(connData).forEach(id => {
                        if (connData[id].length) {
                            connData[id].forEach(c => {
                                console.log(worldData[c].title, "is missing a connection to", worldData[id].title);
                            });
                        }
                    });
                }

                function initLocalization(isInitial) {
                    const isEn = config.lang === "en";

                    $("[data-localize]").localize("ui", {
                        language: config.lang,
                        pathPrefix: "/lang",
                        callback: function (data, defaultCallback) {
                            data.footer = data.footer.replace("{VERSION}", "1.1.0");
                            localizedConns = data.conn;
                            if (isInitial) {
                                Object.keys(data.uiTheme.values).forEach(t => {
                                    $(".js--ui-theme").append('<option data-localize="uiTheme.values.' + t + '" value="' + t + '">' + data.uiTheme.values[t] + '</option>');
                                });
                                $(".js--ui-theme").val(config.uiTheme).change();
                            }
                            updateControlsContainer();
                            defaultCallback(data);
                        }
                    });

                    $.localize("conn", {
                        language: config.lang,
                        pathPrefix: "/lang",
                        callback: function (data) {
                            localizedConns = data;
                        }
                    });

                    if (isInitial) {
                        $.localize("effect", {
                            language: 'ja',
                            pathPrefix: "/lang",
                            callback: function (data) {
                                effectsJP = data;
                            }
                        });
                    }

                    $(".js--world-input").each(function() {
                        const val = $(this).val();
                        if (val && worldNames.indexOf(val) > -1) {
                            const world = worldsByName[worldNames[worldNames.indexOf(val)]];
                            $(this).val(isEn || !world.titleJP ? world.title : world.titleJP);
                        }
                    });

                    worldsByName = isEn ? _.keyBy(worldData, w => w.title) : _.keyBy(worldData, w => w.titleJP || w.title);

                    worldNames = Object.keys(worldsByName);

                    $(".js--world-input").autocomplete("destroy").autocomplete({
                        lookup: worldNames,
                        onSelect: reloadGraph
                    });
                }

                let worldsByName, worldNames, minSize, maxSize, nodes;

                $(document).ready(function () {
                    $(".controls--container--tab__button").click(function() {
                        if ($(".controls-bottom").hasClass("visible")) {
                            $(".controls-bottom").removeClass("visible").animateCss("slideOutDown", 250, function () {
                                if (!$(this).hasClass("visible"))
                                    $(this).css("opacity", 0);
                            });
                            $(".controls--container--tab, .footer").css("margin-top", "0px").animateCss("slideInDown", 300);
                        } else {
                            $(".controls-bottom").addClass("visible").css("opacity", 1).animateCss("slideInUp", 250);
                            $(".controls--container--tab, .footer").css("margin-top", "-" + ($(".controls-bottom").outerHeight() + 8) + "px").animateCss("slideInUp", 250);
                        }
                    });

                    updateControlsContainer();
                    $(window).resize(updateControlsContainer).blur(function() {
                        isShift = false;
                        isCtrl = false;
                    });

                    loadWorldData(false, function (data) {
                        worldData = data;

                        $(".js--lang").change(function() {
                            config.lang = $(this).val();
                            updateConfig();
                            initLocalization();
                            reloadGraph();
                        });

                        $(".js--ui-theme").change(function() {
                            config.uiTheme = $(this).val();
                            const themeStyles = $(".js--theme-styles")[0];
                            getBaseBgColor(config.uiTheme || (config.uiTheme = "Default_Custom"), function (color) {
                                themeStyles.textContent = themeStyles.textContent.replace(/url\(\/images\/ui\/[a-zA-Z0-9\_]+\/(containerbg|border(?:2)?|font\d)\.png\)/g, "url(/images/ui/" + config.uiTheme + "/$1.png)")
                                    .replace(/background-color:( *)[^;]*;( *)\/\*base\*\//g, "background-color:$1" + color + ";$2/*base*/");
                                $(".js--font-style").change();
                                updateConfig();
                            });
                        });

                        $(".js--font-style").change(function() {
                            config.fontStyle = parseInt($(this).val());
                            const themeStyles = $(".js--theme-styles")[0];
                            getFontColor(config.fontStyle, function (baseColor) {
                                getFontColor(config.fontStyle !== 4 ? 4 : 0, function (altColor) {
                                    themeStyles.textContent = themeStyles.textContent = themeStyles.textContent.replace(/url\(\/images\/ui\/([a-zA-Z0-9\_]+)\/font\d\.png\)/g, "url(/images/ui/$1/font" + (config.fontStyle + 1) + ".png)")
                                        .replace(/([^\-])color:( *)[^;]*;( *)\/\*base\*\//g, "$1color:$2" + baseColor + ";$3/*base*/")
                                        .replace(/([^\-])color:( *)[^;]*;( *)\/\*alt\*\//g, "$1color:$2" + altColor + ";$3/*alt*/");
                                    updateConfig();
                                });
                            });
                        });

                        $(".js--display-mode").change(function() {
                            config.displayMode = parseInt($(this).val());
                            updateConfig();
                            reloadGraph();
                            $(".js--stack-size--container").css("display", config.displayMode < 2 ? "flex" : "none");
                        });

                        $(".js--conn-mode").change(function() {
                            config.connMode = parseInt($(this).val());
                            updateConfig();
                        });

                        $(".js--label-mode").change(function() {
                            config.labelMode = parseInt($(this).val());
                            updateConfig();
                        });

                        $(".js--size-diff").change(function() {
                            config.sizeDiff = parseFloat($(this).val());
                            updateConfig();
                            reloadGraph();
                        });

                        $(".js--stack-size").change(function() {
                            config.stackSize = parseInt($(this).val());
                            updateConfig();
                            reloadGraph();
                        });

                        $(".js--reset").click(function() {
                            $(".js--world-input").val("");
                            reloadGraph();
                        });

                        loadOrInitConfig();

                        initLocalization(true);

                        for (let d in Object.keys(worldData)) {
                            const world = worldData[d];
                            world.id = parseInt(d);
                            world.connections.forEach(conn => {
                                const effectParams = conn.typeParams[ConnType.EFFECT];
                                if (effectParams) {
                                    effectParams.paramsJP = effectParams.params.split(',').map(e => effectsJP[e]).join('ã€ã‹ã€Œ');
                                    effectParams.params = effectParams.params.replace(/,/g, ', ');
                                }
                            });
                        }

                        const worldSizes = worldData.map(w => w.size); 

                        minSize = _.min(worldSizes);
                        maxSize = _.max(worldSizes);

                        reloadGraph();
                    });
                });
            </script>
        </div>
    </body>
</html>